<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> nginx负载均衡算法 · Doublekai的博客</title><meta name="description" content="nginx负载均衡算法 - DOUBLEKAI"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/touxiang.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.doublekai.com/atom.xml" title="Doublekai的博客"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Doublekai的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/touxiang.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/doublekai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/doublekai/" target="_blank" class="nav-list-link">BLOG GARDEN</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">nginx负载均衡算法</h1><div class="post-info">Aug 18, 2021</div><div class="post-content"><h4 id="Nginx的背景"><a href="#Nginx的背景" class="headerlink" title="Nginx的背景"></a>Nginx的背景</h4><p>Nginx和Apache一样都是一种WEB服务器。基于REST架构风格，以URI（Uniform Resources Identifier，统一资源描述符）或URL（Uniform Resources Locator，统一资源定位符）作为沟通依据，通过HTTP协议提供各种网络服务。WEB服务器的设计受网络规模、网络带宽、产品特点等因素局限，且各自的定位和发展不同，因此各种WEB服务器有着各自的鲜明特点。</p>
<p>Apache的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多特点：稳定、开源、跨平台等。它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在，所以它被设计为一个重量级的WEB服务器，不支持高并发。在Apache上运行数以万计的并发访问，会导致服务器消耗大量内存。操作系统对其进行进程或线程间的切换也消耗了大量的CPU资源，导致HTTP请求的平均响应速度降低。这些因素都决定了Apache不可能称为高性能的WEB服务器，因此轻量级的高并发服务器Nginx就登上了舞台。</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>代理：在访问google的时候会请求失败，而国外的服务器能访问,所以访问google方式为</p>
<blockquote>
<p>User -&gt; 国外服务器 -&gt;google</p>
</blockquote>
<p>国外服务器就是代理这个过程也称为正向代理<br>反向代理：<br>简单的在拨打110的时候你会发现打到的是离你最近的一个派出所，简单理解就是</p>
<blockquote>
<p>User -&gt; 110 -&gt;  很多服务器</p>
</blockquote>
<p>当我们请求 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 的时候，就像拨打110一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。</p>
<h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p>初始化代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;String, Integer&gt; serviceWeightMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">static &#123;</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.100&quot;, 1);</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.101&quot;, 1); </span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.102&quot;, 5);//权重为5</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.103&quot;, 1);</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.104&quot;, 1);       </span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.105&quot;, 4);//权重为4</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.106&quot;, 1);      </span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.107&quot;, 2);//权重为2</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.108&quot;, 1);</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.109&quot;, 1);</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.110&quot;, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过实例化一个serviceWeightMap的Map变量来服务器地址和权重的映射，以此来模拟轮询算法的实现，其中设置的权重值在以后的加权算法中会使用到，这里先不做过多介绍，该变量初始化如下：</p>
<ol>
<li><p>随机：负载均衡方法随机的把负载分配到各个可用的服务器上，通过随机数生成算法选取一个服务器，然后把连接发送给它。虽然许多均衡产品都支持该算法，但是它的有效性一直受到质疑，除非把服务器的可运行时间看的很重。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static String testRandom() &#123;</span><br><span class="line"> </span><br><span class="line">    // 重新创建一个map，避免出现由于服务器上线和下线导致的并发问题</span><br><span class="line">    Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    serverMap.putAll(serviceWeightMap);</span><br><span class="line"> </span><br><span class="line">    //取得IP地址list</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    ArrayList&lt;String&gt; keyList = new ArrayList&lt;String&gt;();</span><br><span class="line">    keyList.addAll(keySet);</span><br><span class="line"> </span><br><span class="line">    Random random = new Random();</span><br><span class="line">    int randomPos = random.nextInt(keyList.size());</span><br><span class="line">     </span><br><span class="line">    String server = keyList.get(randomPos);</span><br><span class="line">     </span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>轮询：将请求按顺序轮流分配到后台服务器上，均衡的对待每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static Integer pos = 0;</span><br><span class="line"> </span><br><span class="line">public static String testRoundRobin() &#123;</span><br><span class="line">     </span><br><span class="line">    // 重新创建一个map，避免出现由于服务器上线和下线导致的并发问题</span><br><span class="line">    Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    serverMap.putAll(serviceWeightMap);</span><br><span class="line">     </span><br><span class="line">    //取得IP地址list</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    ArrayList&lt;String&gt; keyList = new ArrayList&lt;String&gt;();</span><br><span class="line">    keyList.addAll(keySet);</span><br><span class="line">     </span><br><span class="line">    String server = null;</span><br><span class="line">     </span><br><span class="line">    synchronized (pos) &#123;</span><br><span class="line">        if (pos &gt; keySet.size()) &#123;</span><br><span class="line">            pos = 0;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        server = keyList.get(pos);</span><br><span class="line">         </span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>加权轮询：该算法中，每个机器接受的连接数量是按权重比例分配的。这是对普通轮询算法的改进，比如你可以设定：第三台机器的处理能力是第一台机器的两倍，那么负载均衡器会把两倍的连接数量分配给第3台机器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static String testWeightRoundRobin() &#123;</span><br><span class="line"> </span><br><span class="line">    // 重新创建一个map，避免出现由于服务器上线和下线导致的并发问题</span><br><span class="line">    Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    serverMap.putAll(serviceWeightMap);</span><br><span class="line"> </span><br><span class="line">    //取得IP地址list</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    Iterator&lt;String&gt; it = keySet.iterator();</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; serverList = new ArrayList&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        String server = it.next();</span><br><span class="line">        Integer weight = serverMap.get(server);</span><br><span class="line">        for (int i=0; i&lt;weight; i++) &#123;</span><br><span class="line">            serverList.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    String server = null;</span><br><span class="line"> </span><br><span class="line">    synchronized (pos) &#123;</span><br><span class="line">        if (pos &gt; serverList.size()) &#123;</span><br><span class="line">            pos = 0;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        server = serverList.get(pos);</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="4">
<li><p> 源地址哈希(Hash)法：源地址哈希的思想是获取客户端访问的ip地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是要访问的服务器的序号。采用哈希法进行负载均衡，同一ip地址的客户端，当后端服务器列表不变的时候，它每次都会被映射到同一台后端服务器进行访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static String testConsumerHash(String remoteIp) &#123;</span><br><span class="line"> </span><br><span class="line">    // 重新创建一个map，避免出现由于服务器上线和下线导致的并发问题</span><br><span class="line">    Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    serverMap.putAll(serviceWeightMap);</span><br><span class="line"> </span><br><span class="line">    //取得IP地址list</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    ArrayList&lt;String&gt; keyList = new ArrayList&lt;String&gt;();</span><br><span class="line">    keyList.addAll(keySet);</span><br><span class="line">     </span><br><span class="line">    int hashCode = remoteIp.hashCode();</span><br><span class="line">    int pos = hashCode % keyList.size();</span><br><span class="line">     </span><br><span class="line">    return keyList.get(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最快算法：最快算法基于所有服务器中的最快响应时间分配连接。该算法在服务器跨不同网络的环境中特别有用。</p>
</li>
<li><p>最少连接：系统把新连接分配给当前连接数目最少的服务器。该算法在各个服务器运算能力基本相似的环境中非常有效。</p>
</li>
<li><p>观察算法：该算法同时利用最小连接算法和最快算法来实施负载均衡。服务器根据当前的连接数和响应时间得到一个分数，分数较高代表性能较好，会得到更多的连接。</p>
</li>
<li><p>预判算法：该算法使用观察算法来计算分数，但是预判算法会分析分数的变化趋势来判断某台服务器的性能正在改善还是降低。具有改善趋势的服务器会得到更多的连接。该算法适用于大多数环境。</p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2021/08/18/nginx%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0/" class="prev">PREV</a><a href="/2021/08/17/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%A8%E6%88%B7%E7%9C%9F%E5%AE%9EIP/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 - 2021 <a href="https://www.doublekai.com">DOUBLEKAI</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>