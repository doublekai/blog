<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 双指针使用 · Doublekai的博客</title><meta name="description" content="双指针使用 - DOUBLEKAI"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/touxiang.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.doublekai.com/atom.xml" title="Doublekai的博客"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Doublekai的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/touxiang.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/doublekai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/doublekai/" target="_blank" class="nav-list-link">BLOG GARDEN</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">双指针使用</h1><div class="post-info">Jun 28, 2021</div><div class="post-content"><p>先来看一个简单的题目<br>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reverseString(char[] s) &#123;</span><br><span class="line">     /*</span><br><span class="line">        定义两个指针一个指向头一个指向尾部</span><br><span class="line">        两指针同时移动，将值交换。直到两指针重合或头大于尾则退出循环</span><br><span class="line">        */</span><br><span class="line">        int head=0,tail=s.length-1; //定义两个指针头、尾</span><br><span class="line">        while (head&lt;=tail)&#123;      //循环退出条件</span><br><span class="line">            if(s[head] == s[tail])&#123;  //如果相等则少一次交换</span><br><span class="line">                head++;tail--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char temp=s[head];  //交换头尾值</span><br><span class="line">            s[head++]=s[tail];</span><br><span class="line">            s[tail--]=temp;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一个双指针应用如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。如下图则True有环<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"><br>而下面的则为False<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="代表"><br>方法一：直接将所有节点放在HashSet存储结构中遍历节点当该节点在表中存在则为True。<br>方法二：双指针利用快慢指针的思想，慢指针走得慢，快指针比慢指针快两倍，当快指针和慢指针相遇的时候则必有环为True代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null ||head.next == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode after=head; //慢指针</span><br><span class="line">        ListNode front=head.next;  //快指针</span><br><span class="line">        while (after!=front)&#123;    //当快指针跟慢指针重合则跳出循环 返回True</span><br><span class="line">            if (front == null ||front.next == null)&#123;   //如果快指针为空，说明不是环</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            front=front.next.next;   //快指针移动要比慢指针快一步</span><br><span class="line">            after=after.next;    慢指针正常移动</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>双指针实现奇偶数排序<br>给定一个非负整数数组A， A 中一半整数是奇数，一半整数是偶数。<br>对数组进行排序，以便当A[i] 为奇数时，i也是奇数；当A[i]为偶数时， i 也是偶数。<br>分析：<br>方法一：重新定义一个数组B，遍历A当A[i]为奇数时放入奇数下标中j=1,j+=2,B[j]=A[i]，同理再次遍历A，将偶数放入B中<br>可以看出来时间复杂度为O（n），使用新的空间；<br>方法二：利用双指针<br>1.定义两个指针分别指向偶数下标和奇数下标<br>2.当偶数下标不是偶数时移动奇数下标指针当找到奇数下标不是奇数两个就可以交换<br>可能有点绕口接下来看A=[1,3,0,4] 当A[0]不是偶数时必定存在一个A[j]（j为奇数）不是奇数这里面也就是A[3],所以A[0]&lt;=&gt;A[3]交换则可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int[] sortArrayByParityII(int[] nums) &#123;</span><br><span class="line">        /*</span><br><span class="line">        给定一个非负整数数组A， A 中一半整数是奇数，一半整数是偶数。</span><br><span class="line"></span><br><span class="line">        对数组进行排序，以便当A[i] 为奇数时，i也是奇数；当A[i]为偶数时， i 也是偶数。</span><br><span class="line"></span><br><span class="line">        你可以返回任何满足上述条件的数组作为答案。</span><br><span class="line">        1.定义两个指针分别指向偶数下标和奇数下标</span><br><span class="line">        2.当偶数下标不是偶数时移动奇数下标指针当找到奇数下标不是奇数两个就可以交换</span><br><span class="line">        */</span><br><span class="line">        int odd=1;//奇数指针</span><br><span class="line">        int enev=0;//偶数下标</span><br><span class="line">        while (enev&lt; nums.length)&#123;</span><br><span class="line">            if(nums[enev]%2!=0)&#123;   //如果偶数下标是奇数的话，则找到奇数下标是偶数的交换则可以</span><br><span class="line">                while (nums[odd]%2!=0)&#123;  // 找到奇数下标为偶数的值</span><br><span class="line">                    odd+=2;</span><br><span class="line">                    &#125;</span><br><span class="line">                int temp=nums[odd];   //交换</span><br><span class="line">                nums[odd]=nums[enev];</span><br><span class="line">                nums[enev]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            enev+=2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用指针的过程中，要明白指针真正的含义，指针指向的不是值，而是值所待的地方也就是内存，当你明白这个道理那指针应用就会变得很简单，家都归你了何况家里的物品。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/07/12/%E5%93%8D%E5%BA%94%E4%BD%93%E9%87%8C%E7%9A%84%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/" class="prev">上一篇</a><a href="/2021/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/" class="next">下一篇</a></div><div class="copyright"><p>© 2018 - 2021 <a href="https://www.doublekai.com">DOUBLEKAI</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>