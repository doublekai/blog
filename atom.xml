<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Doublekai的博客</title>
  
  <subtitle>蜗牛的爬行！</subtitle>
  <link href="https://www.doublekai.com/atom.xml" rel="self"/>
  
  <link href="https://www.doublekai.com/"/>
  <updated>2021-07-01T07:26:45.134Z</updated>
  <id>https://www.doublekai.com/</id>
  
  <author>
    <name>DOUBLEKAI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双指针使用</title>
    <link href="https://www.doublekai.com/2021/06/28/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.doublekai.com/2021/06/28/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8/</id>
    <published>2021-06-28T02:07:06.000Z</published>
    <updated>2021-07-01T07:26:45.134Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一个简单的题目<br>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reverseString(char[] s) &#123;</span><br><span class="line">     /*</span><br><span class="line">        定义两个指针一个指向头一个指向尾部</span><br><span class="line">        两指针同时移动，将值交换。直到两指针重合或头大于尾则退出循环</span><br><span class="line">        */</span><br><span class="line">        int head=0,tail=s.length-1; //定义两个指针头、尾</span><br><span class="line">        while (head&lt;=tail)&#123;      //循环退出条件</span><br><span class="line">            if(s[head] == s[tail])&#123;  //如果相等则少一次交换</span><br><span class="line">                head++;tail--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char temp=s[head];  //交换头尾值</span><br><span class="line">            s[head++]=s[tail];</span><br><span class="line">            s[tail--]=temp;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一个双指针应用如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。如下图则True有环<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"><br>而下面的则为False<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="代表"><br>方法一：直接将所有节点放在HashSet存储结构中遍历节点当该节点在表中存在则为True。<br>方法二：双指针利用快慢指针的思想，慢指针走得慢，快指针比慢指针快两倍，当快指针和慢指针相遇的时候则必有环为True代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (head == null ||head.next == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode after=head; //慢指针</span><br><span class="line">        ListNode front=head.next;  //快指针</span><br><span class="line">        while (after!=front)&#123;    //当快指针跟慢指针重合则跳出循环 返回True</span><br><span class="line">            if (front == null ||front.next == null)&#123;   //如果快指针为空，说明不是环</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            front=front.next.next;   //快指针移动要比慢指针快一步</span><br><span class="line">            after=after.next;    慢指针正常移动</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用指针的过程中，要明白指针真正的含义，指针指向的不是值，而是值所待的地方也就是内存，当你明白这个道理那指针应用就会变得很简单，家都归你了何况家里的物品。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先来看一个简单的题目&lt;br&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。&lt;/p&gt;
&lt;p&gt;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;
&lt;p&gt;你可以假设数组中的所有字</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树的操作（非递归）</title>
    <link href="https://www.doublekai.com/2021/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.doublekai.com/2021/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2021-06-22T08:47:22.000Z</published>
    <updated>2021-06-28T02:07:39.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断是否是对称二叉树"><a href="#判断是否是对称二叉树" class="headerlink" title="判断是否是对称二叉树"></a>判断是否是对称二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def isSymmetric(self, root: TreeNode) -&gt; bool:</span><br><span class="line">    if not root:</span><br><span class="line">        return False</span><br><span class="line">    queue = [(root.left, root.right)]# 初始化队列</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    1.空节点返回False</span><br><span class="line">    2.根结点的左等于根结点的右</span><br><span class="line">    3.如果有一个为空则返回False</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    while queue:</span><br><span class="line">        rt1, rt2 = queue.pop()</span><br><span class="line">        if not rt1 and not rt2: #如果都为空则跳过</span><br><span class="line">            continue</span><br><span class="line">        if rt1.val != rt2.val:  #如果不相等 则返回False</span><br><span class="line">            return False</span><br><span class="line">        if not rt1.left and rt2.right:  # 如果左右有一个为空</span><br><span class="line">            return False</span><br><span class="line">        if not rt1.right and rt2.left: #同理</span><br><span class="line">            return False</span><br><span class="line">        queue.append((rt1.left, rt2.right)) #将左树的左节点跟右树的右节点入队</span><br><span class="line">        queue.append((rt1.right, rt2.left)) #同理 将左树的右节点和右树的左节点入队</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><h3 id="二叉树合并"><a href="#二叉树合并" class="headerlink" title="二叉树合并"></a>二叉树合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def mergeTrees(self, root1: TreeNode, root2: TreeNode) -&gt; TreeNode:</span><br><span class="line">    if not root1 or not root2 :</span><br><span class="line">        return  root1 if not root1 else root2  # 如果根结点有一个为空直接返回</span><br><span class="line"></span><br><span class="line">    quese = [(root1, root2)]  #quese=[(1,2)]</span><br><span class="line">    while quese:</span><br><span class="line">        root1, root2 = quese.pop() # root1=1</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">       1.当树a为空 树b也不为空 树a=树a+树b</span><br><span class="line">       2.当树a的左孩子为空,树b的左孩子不为空 树a=树b</span><br><span class="line">        同理。。。</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        if root1 and root2:</span><br><span class="line">            root1.val += root2.val   #root1.val=1+2</span><br><span class="line">        #右孩子 只判断树b的右孩子不为空的情况</span><br><span class="line">        if root1.right and root2.right:</span><br><span class="line">            quese.append((root1.right, root2.right))</span><br><span class="line">        elif not root1.right and root2.right:</span><br><span class="line">            root1.right = root2.right</span><br><span class="line">        # elif root1.right and not root2.right:  # 不用判断</span><br><span class="line">        #     root1.right = root2.right</span><br><span class="line">       #左孩子 同理</span><br><span class="line">        if root1.left and root2.left:</span><br><span class="line">            quese.append((root1.left, root2.left))</span><br><span class="line">        elif not root1.left and root2.left:</span><br><span class="line">            root1.left = root2.left</span><br><span class="line">    return root1</span><br></pre></td></tr></table></figure><h3 id="二叉树的反转-跟判断二叉树对称的方法一样"><a href="#二叉树的反转-跟判断二叉树对称的方法一样" class="headerlink" title="二叉树的反转(跟判断二叉树对称的方法一样)"></a>二叉树的反转(跟判断二叉树对称的方法一样)</h3>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"> def invertTree(self, root: TreeNode) -&gt; TreeNode:</span><br><span class="line">     if not root:</span><br><span class="line">         return None</span><br><span class="line">     queue=[(root.left,root.right)] # 左右孩子入队</span><br><span class="line">     while queue:</span><br><span class="line">         rt1,rt2=queue.pop(0)  #左右孩子出队</span><br><span class="line">         rt1.val,rt2.val = rt2.val,rt1.val # 交换节点的值</span><br><span class="line">         if rt1.left or rt1.right:  # 左右孩子都为空则不入队</span><br><span class="line">             queue.append((rt1.left,rt2.right))</span><br><span class="line">         if rt2.left or rt2.right:</span><br><span class="line">             queue.append((rt1.right,rt2.left)) #同理</span><br><span class="line">     return root</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二叉树结构：把左右节点当作两个根结点的二叉树以此类推。很容易就想到递归。<br>这里用到迭代：把左右节点当作队列或者是栈，利用先进先出或先进后出的思想来完成相应的操作，以此类推每个子树都用这种思想，这样二叉树的一些操作就显得非常简单。</p><p><img src="http://qv8lp3wlj.bkt.gdipper.com/2.jpg" alt="测试图片">   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;判断是否是对称二叉树&quot;&gt;&lt;a href=&quot;#判断是否是对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;判断是否是对称二叉树&quot;&gt;&lt;/a&gt;判断是否是对称二叉树&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tabl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Django入门</title>
    <link href="https://www.doublekai.com/2020/10/26/Django%E5%85%A5%E9%97%A8/"/>
    <id>https://www.doublekai.com/2020/10/26/Django%E5%85%A5%E9%97%A8/</id>
    <published>2020-10-26T09:32:59.000Z</published>
    <updated>2020-10-26T09:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django入门笔记"><a href="#Django入门笔记" class="headerlink" title="Django入门笔记"></a>Django入门笔记</h1><h2 id="Django安装-python2-7"><a href="#Django安装-python2-7" class="headerlink" title="Django安装(python2.7)"></a>Django安装(python2.7)</h2><blockquote><p>版本对照<img src="https://github.com/doublekai/user/blob/master/django.png?raw=true" alt="image"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --default-timeout=100 install -i https://pypi.mirrors.ustc.edu.cn/simple/ django==1.8</span><br></pre></td></tr></table></figure><h2 id="创建第一个项目"><a href="#创建第一个项目" class="headerlink" title="创建第一个项目"></a>创建第一个项目</h2><blockquote><p>进入提前创建的文件夹</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject HelloWorld</span><br><span class="line"></span><br><span class="line">cd HelloWorld/HelloWorld</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>创建xx.py文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">def hello(request):</span><br><span class="line">    return HttpResponse(&quot;Hello,world&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>找到urls.py文件这个文件作用是保存路径和函数的对应关系，代码替换</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import  url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    # Examples:</span><br><span class="line">    # url(r&#x27;^$&#x27;, &#x27;HelloWord.views.home&#x27;, name=&#x27;home&#x27;),</span><br><span class="line">    # url(r&#x27;^blog/&#x27;, include(&#x27;blog.urls&#x27;)),</span><br><span class="line"></span><br><span class="line">    url(r&#x27;^&#x27;, views.hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>在目录下使用命令,启动服务器自己设定端口</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver  127.0.0.1:8000</span><br></pre></td></tr></table></figure><blockquote><p>接下来打开浏览器就能看到</p></blockquote><h2 id="创建MTV项目"><a href="#创建MTV项目" class="headerlink" title="创建MTV项目"></a>创建MTV项目</h2><p>M =model<br>T =view<br>V =controller</p><blockquote><p>同上代码创建项目，在本项目内创建子目录（也就是子功能）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp goods </span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在目录下找到settings.py在INSTALLED_APPS中将刚才两个项目添加进去，运行命令（ip也可以不要）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver </span><br></pre></td></tr></table></figure><h2 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h2><blockquote><p>启动服务 输入密码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start mysql </span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><blockquote><p>我使用的是Navicat for MySQL<br>然后在Djang创建的目录下找到刚才与上面相同的配置文件找到DATABASES修改和添加配置</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">       #数据库的名字</span><br><span class="line">       &#x27;NAME&#x27;:&#x27;&#x27; ,</span><br><span class="line">       #数据库地址</span><br><span class="line">       &#x27;HOST&#x27;:&quot;localhost&quot;,</span><br><span class="line">       #端口</span><br><span class="line">       &#x27;PORT&#x27;:&#x27;3306&#x27;,</span><br><span class="line">       #用户名</span><br><span class="line">       &#x27;USER&#x27;:&#x27;root&#x27;,</span><br><span class="line">       #密码</span><br><span class="line">       &#x27;PASSWORD&#x27;:&#x27;root&#x27;,</span><br></pre></td></tr></table></figure><blockquote><p>在_init__.py中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">importpy mysql</span><br><span class="line"># 因为本身Django不支持mysql语句</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure><blockquote><p>在项目中找到模型也就是models.py中创建数据库表以及字段</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">#商品分类表</span><br><span class="line">class GoodsCategory(models.Model):</span><br><span class="line">    #分类的名称 如果类型是字符串类型 max_length必须要</span><br><span class="line">    cat_name=models.CharField(max_length=30)</span><br><span class="line">    #分类的样式</span><br><span class="line">    cat_css = models.CharField(max_length=20)</span><br><span class="line">    #分类的图片  图片路径</span><br><span class="line">    cat_img = models.ImageField(upload_to=&#x27;cag&#x27;)</span><br><span class="line">#商品表</span><br><span class="line">class GoodsInfo(models.Model):</span><br><span class="line">    #商品名字</span><br><span class="line">    goods_name = models.CharField(max_length=100)</span><br><span class="line">    #商品价格 default 默认为0</span><br><span class="line">    goods_price=models.IntegerField(default=0)</span><br><span class="line">    #商品描述</span><br><span class="line">    goods_desc=models.CharField(max_length=2000)</span><br><span class="line">    #商品图片</span><br><span class="line">    goods_img=models.ImageField(upload_to=&#x27;goods&#x27;)</span><br><span class="line">    #商品分类   定义外键</span><br><span class="line">    goods_cag=models.ForeignKey(&#x27;GoodsCategory&#x27;)</span><br><span class="line"></span><br><span class="line">from django.db import models</span><br><span class="line">class OrderInfo(models.Model):</span><br><span class="line">    status=(</span><br><span class="line">        (1,&#x27;待付款&#x27;),</span><br><span class="line">        (2, &#x27;待发货&#x27;),</span><br><span class="line">        (3, &#x27;待收货&#x27;),</span><br><span class="line">        (4, &#x27;已完成&#x27;),</span><br><span class="line">    )</span><br><span class="line">    #订单编号</span><br><span class="line">    order_id =models.CharField(max_length=100)</span><br><span class="line">    #收货地址</span><br><span class="line">    order_address=models.CharField(max_length=100)</span><br><span class="line">    #收货人</span><br><span class="line">    order_recv=models.CharField(max_length=50)</span><br><span class="line">    #联系电话</span><br><span class="line">    order_phone=models.CharField(max_length=11)</span><br><span class="line">    #运费</span><br><span class="line">    order_fee=models.IntegerField(default=10)</span><br><span class="line">    #订单状态</span><br><span class="line">    order_status=models.IntegerField(default=1,choices=status)</span><br><span class="line"></span><br><span class="line">    #订单备注</span><br><span class="line">    order_extra=models.CharField(max_length=200)</span><br><span class="line">#订单商品表</span><br><span class="line">class OrderGoods(models.Model):</span><br><span class="line">    #所属商品 链接外键</span><br><span class="line">    goods_info=models.ForeignKey(&#x27;goods.GoodsInfo&#x27;)</span><br><span class="line">    #商品数量</span><br><span class="line">    goods_num=models.IntegerField</span><br><span class="line">    #商品所属订单  链接外键</span><br><span class="line">    goods_order=models.ForeignKey(&#x27;OrderInfo&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行语句 第一句会生成两个文件 两个文件就是创建sql语句 也可以用命令查看 第二句是执行sql语句 这时候会在数据库中看到我们创建的表</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><blockquote><p>1.需要创建我们的templates也就是前端页面</p></blockquote><blockquote><p>2.在settings中TEMPLATES列表中’DIRS’: [os.path.join(BASE_DIR,’templates’)],添加我们的路径</p></blockquote><blockquote><p>3.在views中使用render函数返回页面</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return render(request,&#x27;index.html&#x27;)</span><br></pre></td></tr></table></figure><h2 id="模板传值"><a href="#模板传值" class="headerlink" title="模板传值"></a>模板传值</h2><blockquote><p>使用render方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return render(request,&#x27;index.html&#x27;,&#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:19&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在index使用显示</p></blockquote><h2 id="静态显示"><a href="#静态显示" class="headerlink" title="静态显示"></a>静态显示</h2><blockquote><p>新建静态文件夹 在配置文件中添加静态文件的路径</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS=[os.path.join(BASE_DIR,&#x27;static&#x27;)]</span><br></pre></td></tr></table></figure><h2 id="创建主页"><a href="#创建主页" class="headerlink" title="创建主页"></a>创建主页</h2><blockquote><p>最后简单的预览<br><img src="https://github.com/doublekai/user/blob/master/1.png?raw=true" alt="image"></p></blockquote><h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/doublekai/user/">点击找到Pthoto</a></p><h4 id="GitHub上传"><a href="#GitHub上传" class="headerlink" title="GitHub上传"></a>GitHub上传</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new post Django入门 </span><br><span class="line"></span><br><span class="line">hexo g -d</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Django入门笔记&quot;&gt;&lt;a href=&quot;#Django入门笔记&quot; class=&quot;headerlink&quot; title=&quot;Django入门笔记&quot;&gt;&lt;/a&gt;Django入门笔记&lt;/h1&gt;&lt;h2 id=&quot;Django安装-python2-7&quot;&gt;&lt;a href=&quot;#Dja</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue.js基础指令和使用</title>
    <link href="https://www.doublekai.com/2019/04/16/Vue.js%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.doublekai.com/2019/04/16/Vue.js%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2019-04-16T10:59:42.000Z</published>
    <updated>2019-04-16T11:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue的来源"><a href="#Vue的来源" class="headerlink" title="Vue的来源"></a>Vue的来源</h2><p>Vue  是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 </p><h2 id="Vue和jQuery"><a href="#Vue和jQuery" class="headerlink" title="Vue和jQuery"></a>Vue和jQuery</h2><blockquote><p>   如果你使用过JQuery那你对Vue一定爱不释手，jQuery是js的库，而库就是仓库，用来管理我们常用的js调用方法,jQuery的优点就是寻找DOM快，操作DOM灵活。而Vue是js的一种框架。如果你知道怎么使用jQuery那就一定会使用Vue。(最后提醒一下:建议先用原生js实现DOM的操作不要直接接触jQuery和Vue)</p></blockquote><hr><h2 id="Vue的在线使用-当然也可以下载到本地调用"><a href="#Vue的在线使用-当然也可以下载到本地调用" class="headerlink" title="Vue的在线使用(当然也可以下载到本地调用)"></a>Vue的在线使用(当然也可以下载到本地调用)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; </span><br></pre></td></tr></table></figure><h3 id="直接贴代码"><a href="#直接贴代码" class="headerlink" title="直接贴代码"></a>直接贴代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;vue&lt;/title&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;mes&#125;&#125;--&#123;&#123;age&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;ul v-show=&quot;flag&quot; &gt;&lt;!-- v-show表示display属性表示控件是否显示--&gt;</span><br><span class="line">&lt;div&gt;v-for遍历数组元素&lt;/div&gt;</span><br><span class="line">&lt;li v-for=&quot;(v,i) in lists&quot;&gt;&#123;&#123; v &#125;&#125;--&#123;&#123; i &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;div&gt;遍历k vue&lt;/div&gt;</span><br><span class="line">&lt;li v-for=&quot;(v,key) in arr&quot;&gt;&#123;&#123; v &#125;&#125;--&#123;&#123; key &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;div&gt;遍历数组列表元素&lt;/div&gt;</span><br><span class="line">&lt;li v-for=&quot;(v,i) in arrlist&quot;&gt;&#123;&#123; v &#125;&#125;--&#123;&#123; i &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;li v-for=&quot;(v,i) in arrlist&quot;&gt;&#123;&#123; v.name &#125;&#125;--&#123;&#123; v.id &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;button v-on:click=&quot;clike2&quot;&gt;点击2&lt;/button&gt;&lt;!--点击按钮2 age=25 flag=true（控件显示）显示呜呜呜--&gt;</span><br><span class="line">&lt;button  v-on:click=&quot;clike1&quot;&gt;点击1&lt;/button&gt;&lt;!--点击按钮1 age=21 flag=false（控件消失） 显示哈哈哈--&gt;</span><br><span class="line">&lt;p v-if=&quot;age==19&quot;&gt;嘿嘿嘿&lt;/p&gt; </span><br><span class="line">&lt;p v-else-if=&quot;age==21&quot;&gt;哈哈哈&lt;/p&gt;</span><br><span class="line">&lt;p v-else&gt;呜呜呜&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//实例化一个Vue对象</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &quot;#root&quot;, </span><br><span class="line">data:&#123;</span><br><span class="line">mes:&quot;hello&quot;, //显示内容</span><br><span class="line">flag:true,  </span><br><span class="line">age:19,//初始化年龄为19</span><br><span class="line">lists: [&#x27;Jake&#x27;,&#x27;Boy&#x27;,&#x27;Alies&#x27;],</span><br><span class="line">arr:&#123;name:&quot;aa&quot;,id:0001,name:&quot;bb&quot;,id:0002&#125;,</span><br><span class="line">arrlist:[&#123;name:&quot;cccc&quot;,id:00003&#125;,&#123;name:&quot;dddd&quot;,id:00005&#125;,&#123;name:&quot;ffff&quot;,id:00004&#125;]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">clike1:function () &#123;</span><br><span class="line">this.age=21;</span><br><span class="line">this.mes=&quot;看我&quot;;</span><br><span class="line">this.flag=false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* body... */</span><br><span class="line">&#125;,</span><br><span class="line">clike2:function()&#123;</span><br><span class="line">this.mes=&quot;再看我&quot;;</span><br><span class="line">this.flag=true;</span><br><span class="line">this.age=25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><p>Vue框架常用参数含义</p><ul><li>el：Element,就是节点</li><li>data：存放属性的经过后台响应返回H5显示 这些值改变前台随之改变</li><li> methods：存放函数的地方</li><li> filters： 过滤器（比如服务器上代表性别是0和1,在浏览器我们看到的是男女,这就需要我们用过滤器来实现。）</li></ul><hr><p>上面代码主要是Vue的基本指令遍历数组、遍历对象和if-else的基本使用，具体看注释。</p><h6 id="还有很多用多了自然会用，不用刻意去记一些单词"><a href="#还有很多用多了自然会用，不用刻意去记一些单词" class="headerlink" title="还有很多用多了自然会用，不用刻意去记一些单词"></a>还有很多用多了自然会用，不用刻意去记一些单词</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue的来源&quot;&gt;&lt;a href=&quot;#Vue的来源&quot; class=&quot;headerlink&quot; title=&quot;Vue的来源&quot;&gt;&lt;/a&gt;Vue的来源&lt;/h2&gt;&lt;p&gt;Vue  是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浅谈HTTP</title>
    <link href="https://www.doublekai.com/2018/10/25/%C7%B3%CC%B8HTTP/"/>
    <id>https://www.doublekai.com/2018/10/25/%C7%B3%CC%B8HTTP/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2018-10-26T04:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><blockquote><p>网络模型一般是指 OSI 七层参考模型和 TCP/IP 五层参考模型。（也有分为四层的，物理和数据链路为一层<br>大致参考下图！<br><img src="https://github.com/doublekai/user/blob/master/xiyi.png?raw=true" alt="image"></p></blockquote><blockquote><p> 我们现在常用的是TCP/IP模型又称为TCP/IP协议族，每一层分别有很多协议。而计算机之间的通信要通过这些被别人定义好的协议才能互相访问。</p></blockquote><h4 id="各部分及功能"><a href="#各部分及功能" class="headerlink" title="各部分及功能"></a>各部分及功能</h4><blockquote><p>1、应用层：针对你特定应用的协议<br>2、表示层：设备固定的数据格式和网络标准数据格式之间的转化<br>3、会话层：通信管理，负责建立和单开通信连接，管理传输层 以下分层<br>4、传输层：管理两个节点之间的数据传递。负责可靠传输<br>5、网络层：地址管理和路由选择<br>6、数据链路层：互联设备之间传送和识别数据帧<br>7、物理层：界定连接器和网线之间的规格</p></blockquote><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><blockquote><p>超文本传输协议（HTTP）是一种为分布式的，协作的，超媒体信息系统，它是面向应用层的协议。</p></blockquote><h4 id="总体操作"><a href="#总体操作" class="headerlink" title="总体操作"></a>总体操作</h4><blockquote><p>HTTP 协议是一种请求/响应型的协议。 客户端给服务器发送请求的格式是一个请求方法(request method)，URI，协议版本号，然后紧接着一个包含请求修饰符(modifiers)，客户端信息，和可能的消息主体的类 MIME(MIME-like)消息。服务器对请求端发送响应的格式 是以一个状态行(status line)，其后跟随一个包含服务器信息、实体元信息和可能的实体主体 内容的类 MIME(MIME-like)的消息。其中状态行(status line)包含消息的协议版本号和一 个成功或错误码。<br><img src="//upload-images.jianshu.io/upload_images/2964446-5a35e17f298a48e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" alt="enter description here"></p></blockquote><h4 id="常见协议参数"><a href="#常见协议参数" class="headerlink" title="常见协议参数"></a>常见协议参数</h4><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><blockquote><p>http_URL = “http:” “//“ host [ “:” port ] [ abs_path [ “?” query ]]<br>port不指明默认为80</p></blockquote><h5 id="协议版本号"><a href="#协议版本号" class="headerlink" title="协议版本号"></a>协议版本号</h5><blockquote><p>HTTP 使用一个<code>&lt;major&gt;.&lt;minor&gt;</code>数字模式来指明协议的版本号。（具体请参考《HTTP协议》）</p></blockquote><h5 id="请求（Request）"><a href="#请求（Request）" class="headerlink" title="请求（Request）"></a>请求（Request）</h5><blockquote><p>一个请求消息是从客户端到服务器端的，在消息首行里包含方法，资源指示符，协议版本。<br>Request = Request-Line ; Section 5.1 *(( general-header ; Section 4.5|request-header ; Section 5.3| entity-header ) CRLF) ; Section 7.1CRLF[ message-body ] ; Section 4.3</p></blockquote><h5 id="请求（Response）"><a href="#请求（Response）" class="headerlink" title="请求（Response）"></a>请求（Response）</h5><blockquote><p>接收和解析一个请求消息后，服务器发出一个 HTTP 响应消息。<br>response =Status-Line*(( general-header)|response-header|entity-header)CRLF）|CRLF[ message-body ]</p></blockquote><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><blockquote><p>-1xx :报告的   -请求被接收到，继续处理<br>-2xx :成功 (accepted)的动作 。    -被成功地接收(received).<br>-3xx :重发    -为了完成请求必须采取进一步的动作。<br>-4xx :客户端出错        - 请求包括错的语法或不能被满足。<br>-5xx :服务器出错  -服务器无法完成显然有效的请求。<br>常见状态码</p><blockquote><p>200 OK                        //客户端请求成功<br>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden                 //服务器收到请求，但是拒绝提供服务<br>404 Not Found                 //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error     //服务器发生不可预期的错误<br>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p></blockquote></blockquote><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><blockquote><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>GET     请求指定的页面信息，并返回实体主体。<br>HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>PUT     从客户端向服务器传送的数据取代指定的文档的内容。<br>DELETE      请求服务器删除指定的页面。<br>CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>OPTIONS     允许客户端查看服务器的性能。<br>TRACE     回显服务器收到的请求，主要用于测试或诊断。</p></blockquote><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><blockquote><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p></blockquote><h4 id="以下是-HTTP-请求-响应的步骤："><a href="#以下是-HTTP-请求-响应的步骤：" class="headerlink" title="以下是 HTTP 请求/响应的步骤："></a>以下是 HTTP 请求/响应的步骤：</h4><blockquote><p>1、客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn./">http://www.oakcms.cn。</a></p></blockquote><blockquote><p>2、发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p></blockquote><blockquote><p>3、服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p></blockquote><blockquote><p>4、释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></blockquote><blockquote><p>5、客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></blockquote><blockquote><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p></blockquote><blockquote><p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p></blockquote><blockquote><p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p></blockquote><blockquote><p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p></blockquote><blockquote><p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p></blockquote><blockquote><p>5、释放 TCP连接;</p></blockquote><blockquote><p>6、浏览器将该 html 文本并显示内容;<br>具体参考<a href="https://www.cnblogs.com/ranyonsue/p/5984001.html">enter description here</a><br>和《HTTP协议》。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;网络模型一般是指 OSI 七层参考模型和 TCP/IP 五层参考模型。（也有分为四层的，物理和数据</summary>
      
    
    
    
    
    <category term="网络" scheme="https://www.doublekai.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>如何利用Markdown写文章</title>
    <link href="https://www.doublekai.com/2018/07/16/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Markdown%E5%86%99%E6%96%87%E7%AB%A0/"/>
    <id>https://www.doublekai.com/2018/07/16/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Markdown%E5%86%99%E6%96%87%E7%AB%A0/</id>
    <published>2018-07-16T10:06:00.000Z</published>
    <updated>2018-07-19T13:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法说明"><a href="#Markdown语法说明" class="headerlink" title="Markdown语法说明"></a>Markdown语法说明</h1><blockquote><p>首先来个h2标题就叫做Markdown语法说明<br>在给标题下面定义好ul列表作为目录<br>然后是一个h6副标题和一个&gt;引用</p></blockquote><h2 id="简单的标题"><a href="#简单的标题" class="headerlink" title="简单的标题"></a>简单的标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">##  h2</span><br></pre></td></tr></table></figure><blockquote><p>h1 == #    （后面加入一个制表符或空格）<br>h2 == ##<br>…… </p></blockquote><p>接下来看一段文字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[link](https://www.cnblogs.com/doublekai &quot;title&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>   link代表文字 （）包含链接和title</p></blockquote><p><a href="https://www.cnblogs.com/doublekai" title="博客园">点击我,能跳转到Doublekai的blog</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>这里是正常的内容<br>接下来是加了 &gt;</p><blockquote><p>  看这就是引用</p><blockquote><p> 我是二级引用</p><blockquote><p>我是三级引用</p><blockquote><p>   我是n层引用</p></blockquote></blockquote></blockquote></blockquote><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>插入图片的格式就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](图片链接 &quot;optional title&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>   Alt text：图片的Alt标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 图片链接：可以是图片的本地地址或者是网址。”optional title”：鼠标悬置于图片上会出现的标题文字，可以不写。</p></blockquote><hr><p><img src="/images/wechat.png" alt="image" title="图片"></p><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><blockquote><p>  插入代码用三个 ` 来表示<br>接下来是一段定义结构体的代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//因为这段时间专升本在学数据结构所以就拿来做实验了</span><br><span class="line">#include &quot;stdio&quot; //代码光亮不错</span><br><span class="line">#define maxlen 100</span><br><span class="line">typedef struct&#123;   //看来对各种语言关键字都懂啊！</span><br><span class="line">    ElemType data[maxlen];</span><br><span class="line">    int listlen;</span><br><span class="line">    </span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>   上面是一段数据结构代码 关键字都识别<br>    再来看一下 python</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import re </span><br><span class="line">for i in rang(0,10):</span><br><span class="line">    print i</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>   再来一段html可以看到基本上对语言识别度很好。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">        在加个脚本语言</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        console.log(&#x27;hello,word&#x27;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>   下面是整个页面的md</p></blockquote></blockquote><p><img src="/images/t1.png" alt="image"><br><img src="/images/t2.png" alt="image"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown语法说明&quot;&gt;&lt;a href=&quot;#Markdown语法说明&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法说明&quot;&gt;&lt;/a&gt;Markdown语法说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;首先来个h2标题就叫做Markdo</summary>
      
    
    
    
    
    <category term="文章" scheme="https://www.doublekai.com/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://www.doublekai.com/2018/07/14/%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.doublekai.com/2018/07/14/%E6%B5%8B%E8%AF%95/</id>
    <published>2018-07-14T03:58:01.000Z</published>
    <updated>2018-07-15T10:05:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h3><p>测试内容时间为：12：04</p><hr><p><code>printf(&quot;    hello,word&quot;)</code>  ;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;大标题&quot;&gt;&lt;a href=&quot;#大标题&quot; class=&quot;headerlink&quot; title=&quot;大标题&quot;&gt;&lt;/a&gt;大标题&lt;/h3&gt;&lt;p&gt;测试内容时间为：12：04&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;printf(&amp;quot;    hello,word&amp;quot;)</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python 多线程</title>
    <link href="https://www.doublekai.com/2018/07/14/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.doublekai.com/2018/07/14/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2018-07-14T03:58:01.000Z</published>
    <updated>2021-06-21T15:23:25.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是多线程和多进程？"><a href="#什么是多线程和多进程？" class="headerlink" title="什么是多线程和多进程？"></a>什么是多线程和多进程？</h3><p><img src="/images/thread.png" alt="image"></p><ul><li>根据上图可以看出来多线程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是多线程和多进程？&quot;&gt;&lt;a href=&quot;#什么是多线程和多进程？&quot; class=&quot;headerlink&quot; title=&quot;什么是多线程和多进程？&quot;&gt;&lt;/a&gt;什么是多线程和多进程？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/thread.png&quot; alt=</summary>
      
    
    
    
    
  </entry>
  
</feed>
